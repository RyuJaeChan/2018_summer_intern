Ch3
========

4) HTML templating
-------------------
웹화면에 데이터를 받아와서 표시한다거나. 웹 하면에 있는 내용을 삭제한다거나 등등 작업을 한다. HTML태그들이 다양하게 변경되어야 하는데 HTML과 데이터를 섞어서 화면에 변경을 주는 방법

HTML Templating 작업이란?
동일한 내용의 리스트들을 비슷한 태그를 이용해 표시하는 경우 여러 태그들을 하나로 묶어서 화면에 추가하는 작업
렌더링을 서버에서하느냐 클라이언트에서 할까는 주요 쟁점 : 적절한 방법을 선택히야 한다.

데이터만 필요할때 받아와서 HTML 테블릿과 결합하여 화면에 추가하는 작업

```
<li>
	<h2>(title)</h2>
<li>

+

{
	title:"my title"
}
```

```javascript
var data={
	title : "my title",
    content : "data text",
    price : 2000
};

var html = "<li><h2>{title}</h2>{content}{price}</li>

//replace를 이용하는 방법
var resultHTML = html.replace("{title}", data.title)
				.replace("{content}", data.content)
				.replace("{price}", data.price)	//method channing
```

5) HTML Templating 실습

HTML 템플릿을 어떻게 보관하고 화면에 적용할 수 있는가...


```
var html = "<li><h2>{title}</h2>{content}{price}</li>
```
이런걸 자파스크립트 코드에서 가지고 있는건 좋지 않은 방법이다
- 서버에서 파일로 보관하고 Ajax로 요청해 받아온다.
- HTML 코드안에 숨겨둥다(?)

Templating
HTML 중 script 태그는 type이 javascript가 아니면 렌더링하지 않고 무시한다. 이걸 이용해 템플릿을 숨겨둘 수 있다.
```

//... html 코드들

<script id="template-list-item" type="text/template">	//가져올 템플릿
<li>
	<h2>{title}</h2>
   	<p>{content}</p>
    <div>{price}</div>
</li>
</script>
<script>
	//mock data
	var data=[ {
		title : "my title",
    	content : "data text",
    	price : 2000
	}
    ];

	var template = document.querySelector("teplate-list-item").innerHTML;
    var resultHTML = html.replace("{title}", data.title)
				.replace("{content}", data.content)
				.replace("{price}", data.price)	//method channing

    document.querySelector(".content").innerHTML = resultHTML;
</script>
```
이런 방식으로 가져올 수 있다.

템플릿을 조작하는 방법? replace 말고 뭐가 있을까
템플릿 보관
	간단한건 이렇게 해도 되지만 템플릿 자겅ㅂ을 많이 할 경우 서버단에 템플릿을 만들어 놓고 Ajax로 서버에서 데이터를 받아와서 쓰는방법이있고
    ES6에는 템플릿 리터럴을 쓰면 replace없이 간단히 할 수 있다(모든 브라우저 지원하는건 아님)`

6. Tab UI 실습

컴포넌트 : Calandar, 검색창, 숫자버튼 등등
Tab도 이런 컴포넌트 중 하나






7. Spring Core - BE

1)


###2) Spring DI/IoC

[참고링크](http://www.nextree.co.kr/p11247/)

#### 컨테이너란?
- 컨테이너는 인스턴스의 생명 주기를 관리한다.
- 생성된 인스턴스들에게 추가적인 기능을 제공한다.

WAS는 메모리를 올린 후 실행한다. 개발자가 작성한 서블릿을 실제 메모리에 올리고 실행하는 WAS가 가지고 있는  서블릿 컨테이너가 실행하는 것이다.

#### IOC란?
- Inversion of Control의 약어
- 개발자는 프로그램의 흐름을 제어하는 코드를 작성한다. 이 흐름의 제어를 개발자가 하는 것이 아니라 다른 프로그램이 하는 것을 IoC라고 한다.

동일한 인터페이스를 통해 사용자가 쓰는 입장에서 동일하게 구현해서 동일한 사용이 가능하도록 제공한다.
스프링이 가지고 있는 BeanFactory와 Application Context가 공장 같은 역할을 해준다.

#### DI란?
- 의존성 주입 받는 방법
- 공장이 만든 인스턴스를 내가 사용할 수 있도록 해주는거
DI는 클래스 사이의 의존관계를 빈(Bean) 설정 정보를 바탕을 ㅗ컨테이너가 자동으로 연결해 주는 것을 말한다.

DI가 적용 안된 예

``` java
class 엔진 {

}

class 자동차 {
     엔진 v = new 엔진();
}
```

DI가 적용된 예
- 엔진 tpye의 v 변수에 아직 인스턴스가 할당되지 앟ㄴ았따.
- 컨테이너가 v변수에 인스턴스를 할당해주게된다.


```java
@Component
class 엔진 {

}

@Component
class 자동차 {
     @Autowired
     엔진 v;
}
```

#### Spring에서 제공하는 IoC/DI 컨테이너
- BeanFactory : IoC/DI에 대한 기본기능을 가지고 있따.
- ApplicatoinConext : BeanFactory의 모든 기능 + 부가기능 : 일반적으로 추천된다.
- BeanPostProcessor는 컨테이너의 기본 로직을 오버라이딩 해서 인스턴스화와 의존성 처리 로직 등을 개발자가 원하는 대로 구현할 수 있게 해주는 것
- BeanFactorypostProcessor 설정 메타 데이터를 커스트마이징
- 공장에서 객체를 만드는데 사용자가 원하는 방법으로 만들어내고 사용하는 것을 도와준다.



### 3) xml파일을 이용한 설정

이클립스 -> file -> New -> maven project 생성
경로 설정 -> Artifact Id : maven-archetype-quickstart 선택
그룹id articact id 설정 -> finish

pom.xml 설정 : jdk 사용을 위한 plugin 추가

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>kr.or.connect</groupId>
  <artifactId>diexam01</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <packaging>jar</packaging>

  <name>diexam01</name>
  <url>http://maven.apache.org</url>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
  </properties>

  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>3.8.1</version>
      <scope>test</scope>
    </dependency>
  </dependencies>
  
-------------------------------------추가----------------------------------------------------
  <build>
     <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.6.1</version>
            <configuration>
                <source>1.8</source>
                <target>1.8</target>
            </configuration>
        </plugin>
    </plugins>
  </build>
----------------------------------------------------------------------------------------------

</project>
```

juint에 빨간줄 나오는거 없애기
problem 탭 -> warning 보면 업데이트하라고 나와있음
project 우클릭 -> maven -> update 하면됨
![프로젝트익스플로러](https://i.imgur.com/miGi2qf.png)
App.java와 AppTest.java를 볼 수 ㅣㅇㅆ다.

![testjava](https://i.imgur.com/JjHmNmE.png)
```
junit.framework.Test;
```
단위 테스트 할 수 있는 도구이다.

![test](https://i.imgur.com/hpwMMgV.png)
저걸 누르면 테스트 할 수 있다.

#### DI 주입하는거 테스트

```java
package com.nts.connect.diexam01;

public class UserBean {

}
```








JBC 프로그래밍
-------------

### 1) Spring JDBC 소개

- jdbc 프로그래밍을 보면 반복되는 개발요소가 있다.
- 스프링 프레임워크가 저수준 세부사항을 처리해준다.
- 개발자는 필요한 부분만 정의

개발자가 할거 : 연결 파라미터 정의, SQL문 지정, 파라미터 선언과 파라미터 값 제공, 각 이터레이션에 대한 작업 수행

#### Spring JDBC 패키지
- org.springframework.jdbc.core : JDBC 템ㅍ플릿 클래스와 JDBC 템플릿의 다양한 콜백 인터페이스 포함, 추가 관련 클래스 포함
- org.springframework.jdbc.datasource : 데이터 소스 접근을 쉽게하는 유틸리티 클래스와  javaEE 컨테이너 외부에 수정되지 않고 운영되는 JDBC 코드, 테스트에서 사용할 수 있는 간단한 데이터소스 구현체 포함
- org.springframework.jdbc.object : RDBMS의 조회 갱신 저장 프로시저를 스레드 세이프하고 재상용 가능한 객체로 나타내는 클래스 포함
- org.springframework.jdbc.support : SQL Exception 변환 기능과 약간의 유틸리티 클래스

#### JDBC Template

- org.springframework.jdbc.core에서 가장 중요한 클래스입니다.
- 리소스 생성, 해지를 처리해서 연결을 닫는 것을 잊어 발생하는 문제 등을 피할 수 있도록 합니다.
- 스테이먼트(Statement)의 생성과 실행을 처리합니다.
- SQL 조회, 업데이트, 저장 프로시저 호출, ResultSet 반복호출 등을 실행합니다.
- JDBC 예외가 발생할 경우 org.springframework.dao패키지에 정의되어 있는 일반적인 예외로 변환시킵니다.


한건
```java
Actor actor = this.jdbcTemplate.queryForObject(

  "select first_name, last_name from t_actor where id = ?",

  new Object[]{1212L},

  new RowMapper<Actor>() {

    public Actor mapRow(ResultSet rs, int rowNum) throws SQLException {

      Actor actor = new Actor();

      actor.setFirstName(rs.getString("first_name"));

      actor.setLastName(rs.getString("last_name"));

      return actor;

    }

  });
```

여러건 조회
```java
List<Actor> actors = this.jdbcTemplate.query(

  "select first_name, last_name from t_actor",

  new RowMapper<Actor>() {

    public Actor mapRow(ResultSet rs, int rowNum) throws SQLException {

      Actor actor = new Actor();

      actor.setFirstName(rs.getString("first_name"));

      actor.setLastName(rs.getString("last_name"));

      return actor;

    }

  });

```

### 2) Spring JDBC 실습

#### DTO란?
- DataTransfer Object의 약자
- 계층간 데이터 교환을 위한 JavaBeans
- 계층이란 컨트롤러 뷰, 비지니스 계층, 퍼시스턴스 계층
- 로직을 가지고 있지 않은 순수한 데이터 객체

#### DAO란?
- Data Access Object
- 데이터를 조회하거나 조작하는 기능을 전담
- 데이터 베이스를 조작하는 기능을 전담하는 목적

#### ConnectionPool
- 프로그램이 DBMS에 접속하는 시간이 오래 걸린다. : 비용이 크다
- 빠른 접근을 위해 커넥션을 미리 많이 맺어준다.
- 커넥션이 필요하면 커넥션 풀에게 빌려 사용 후 반납한다.
- 커넥션 풀에 사용 가능한 커넥션이 없으면 대기

#### DataSource
- 커넥션 풀을 관리하는 목적으로 사요오디는 객체
- 커넥션을 얻어어고 반납하는 작업


1. 스프링 컨테이너 ApplicationConext config를 읽는다.
2. componentScanAnnotation이 DAO클래스를 찾도록 설정
3. 찾은 모든 DAO 클래스는 스프링 컨테이너가 관리
4. Application Context가 DBConfig 클래스 import
5. DBConfig 클래스는 데이터 소스와 트랜잭션 매니저 객체 생성
6. DAO는 필드로 NamedParameterJdbcTemplate와 SimpleJdbcInsert를 가진다. : DATA Sourece를 필요로한다. SQL 실행을 편리하게 하도록
7. 파라미터와 SQL을 신경써야한다.


#### 실습

1 Maven 프로젝트 생성 -> quickstart
![01](https://i.imgur.com/S8FjH06.png)

2 id 설정하고 finish

3 porm.xml
database, mysql, data source 추가
해주고 maven->update project 실행
```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>com.nts.connect</groupId>
  <artifactId>daoexam</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <packaging>jar</packaging>

  <name>daoexam</name>
  <url>http://maven.apache.org</url>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <!-- 버전 관리를 위해 상수처럼 쓸 수 있도록-->
    <!-- ${spring.version} 이렇게 사용 가능-->
    <spring.version>4.3.5.RELEASE</spring.version>
  </properties>

  <dependencies>
  <!-- Spring -->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-context</artifactId>
			<version>${spring.version}</version>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-jdbc</artifactId>
			<version>${spring.version}</version>
		</dependency>

		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-tx</artifactId>
			<version>${spring.version}</version>
		</dependency>

		<!-- basic data source -->
		<dependency>
			<groupId>org.apache.commons</groupId>
			<artifactId>commons-dbcp2</artifactId>
			<version>2.1.1</version>
		</dependency>

		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<version>5.1.45</version>
		</dependency>
		
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>3.8.1</version>
      <scope>test</scope>
    </dependency>
  </dependencies>
  <!-- JRE 1.8로 -->
  <build>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<version>3.6.1</version>
				<configuration>
					<source>1.8</source>
					<target>1.8</target>
				</configuration>
			</plugin>
		</plugins>
	</build>
</project>
```

4 ApplicationConfig 클래스 생성
```java
package com.nts.connect.daoexam.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

@Configuration //config라고 명시 실행되면서 여기 설정에 대한 정보를 읽을 수 있다.
@ComponentScan(basePackages = {"com.nts.connect.daoexam.dao"}) //Bean등록 방법으로 Annotation을 했으니 이걸 추가해야한다. 패키지를 여러개 나열할 수있다.
@Import({DBConfig.class}) //설정 파일을 여러개로 나누어서 사용할 수 있다.
public class ApplicationConfig {

}
```


5 테스트코드 실행
```java
package com.nts.connect.daoexam.main;

import java.sql.Connection;

import javax.sql.DataSource;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

import com.nts.connect.daoexam.config.ApplicationConfig;

public class DataSourceTest {

	public static void main(String[] args) {
		ApplicationContext ac = new AnnotationConfigApplicationContext(ApplicationConfig.class);
		DataSource ds = ac.getBean(DataSource.class);

		try (Connection conn = ds.getConnection()) {
			if (conn != null) {
				System.out.println("접속 성공^^");
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

}
```
---

###### 테스트 오류
maven dependencies가 충돌이 일어나서 그런듯
![03](https://i.imgur.com/cBvuP2b.png)
패키지에 빨간줄 뜨면서 안됨
```
The type org.springframework.context.support.GenericApplicationContext cannot be resolved. It is indirectly referenced from required .class files
```
이클립스 끄고 ```
C:\Users\USER\.m2\repository\org
```에서 spingframework 지우고 다시 이클립스 들어가서 maven update



#### query select 실습


DTO 생성
```java
package com.nts.connect.daoexam.dto;

public class Role {
	private int roleId;
	private String description;

	public int getRoleId() {
		return roleId;
	}

	public void setRoleId(int roleId) {
		this.roleId = roleId;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}
    @Override
	public String toString() {
		return "Role [roleId=" + roleId + ", description=" + description + "]";
	}
}
```

RoleDaoSqls

```java
package com.nts.connect.daoexam.dao;

public class RoleDaoSqls {
	public static final String SELECT_ALL = "SELECT role_id, description FROM role ORDER BY role_id";
}

```

```java
package com.nts.connect.daoexam.dao;

import static com.nts.connect.daoexam.dao.RoleDaoSqls.SELECT_ALL;

import java.util.Collections;
import java.util.List;

import javax.sql.DataSource;

import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.simple.SimpleJdbcInsert;
import org.springframework.stereotype.Repository;

import com.nts.connect.daoexam.dto.Role;

@Repository
public class RoleDao {
	private NamedParameterJdbcTemplate jdbc;
	private SimpleJdbcInsert insertAction;
	private RowMapper<Role> rowMapper = BeanPropertyRowMapper.newInstance(Role.class);

	public RoleDao(DataSource dataSource) {
		this.jdbc = new NamedParameterJdbcTemplate(dataSource);
		this.insertAction = new SimpleJdbcInsert(dataSource)
			.withTableName("role");
	}

	public List<Role> selectAll() {
		return jdbc.query(SELECT_ALL, Collections.emptyMap(), rowMapper);
	}

}
```

Select All Test
```java
package com.nts.connect.daoexam.main;

import java.util.List;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

import com.nts.connect.daoexam.config.ApplicationConfig;
import com.nts.connect.daoexam.dao.RoleDao;
import com.nts.connect.daoexam.dto.Role;

public class SelectAllTest {

	public static void main(String[] args) {
		ApplicationContext ac = new AnnotationConfigApplicationContext(ApplicationConfig.class);

		RoleDao roleDao = ac.getBean(RoleDao.class);

		List<Role> list = roleDao.selectAll();

		for (Role element : list) {
			System.out.println(element);
		}
	}

}
```

###### 근데 role_id가 roleID로 자동으로 변환되는데 DB필드에 role_id와 roleId가 같이있으면 어떻게 될까?

```
+---------+--------+-------------+
| role_id | roleId | description |
+---------+--------+-------------+
|   10001 | 200001 | hello       |
|   10002 | 200002 | hello11     |
|   10003 | 200003 | world       |
+---------+--------+-------------+
```

```
RoleDto [roleId=0, role_id=10001, description=hello]
RoleDto [roleId=0, role_id=10002, description=hello11]
RoleDto [roleId=0, role_id=10003, description=world]
```
roleId는 아예 처리하지 않는 것을 볼 수 있다.


##### query insert 실습


dao에 insert 메소드 정의
```java
package com.nts.connect.daoexam.dao;

import static com.nts.connect.daoexam.dao.RoleDaoSqls.SELECT_ALL;

import java.util.Collections;
import java.util.List;

import javax.sql.DataSource;

import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.jdbc.core.simple.SimpleJdbcInsert;
import org.springframework.stereotype.Repository;

import com.nts.connect.daoexam.dto.RoleDto;

@Repository
public class RoleDao {
	private NamedParameterJdbcTemplate jdbc;
	private SimpleJdbcInsert insertAction;
	private RowMapper<RoleDto> rowMapper = BeanPropertyRowMapper.newInstance(RoleDto.class);

	public RoleDao(DataSource dataSource) {
		this.jdbc = new NamedParameterJdbcTemplate(dataSource);
		this.insertAction = new SimpleJdbcInsert(dataSource)
			.withTableName("role");
	}

	public List<RoleDto> selectAll() {
		return jdbc.query(SELECT_ALL, Collections.emptyMap(), rowMapper);
	}

	public int insert(RoleDto dto) {
		SqlParameterSource params = new BeanPropertySqlParameterSource(dto);
		return insertAction.execute(params);
	}
}
```

테스트 코드
```java
package com.nts.connect.daoexam.main;

import java.util.List;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

import com.nts.connect.daoexam.config.ApplicationConfig;
import com.nts.connect.daoexam.dao.RoleDao;
import com.nts.connect.daoexam.dto.RoleDto;

public class TestMain {

	public static void main(String[] args) {
		ApplicationContext ac = new AnnotationConfigApplicationContext(ApplicationConfig.class);

		RoleDao roleDao = ac.getBean(RoleDao.class);

		List<RoleDto> list = roleDao.selectAll();

		for (RoleDto element : list) {
			System.out.println(element);
		}

		RoleDto role = new RoleDto();
		role.setRoleId(100);
		role.setDescription("insert test");

		int cnt = roleDao.insert(role);
		System.out.println("cnt : " + cnt);

		list = roleDao.selectAll();

		for (RoleDto element : list) {
			System.out.println(element);
		}
	}

}

```

##### Update 싫습


dao에 update 메소드 추가

```java
package com.nts.connect.daoexam.dao;

import static com.nts.connect.daoexam.dao.RoleDaoSqls.SELECT_ALL;
import static com.nts.connect.daoexam.dao.RoleDaoSqls.UPDATE;

import java.util.Collections;
import java.util.List;

import javax.sql.DataSource;

import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.jdbc.core.simple.SimpleJdbcInsert;
import org.springframework.stereotype.Repository;

import com.nts.connect.daoexam.dto.RoleDto;

@Repository
public class RoleDao {
	private NamedParameterJdbcTemplate jdbc;
	private SimpleJdbcInsert insertAction;
	private RowMapper<RoleDto> rowMapper = BeanPropertyRowMapper.newInstance(RoleDto.class);

	public RoleDao(DataSource dataSource) {
		this.jdbc = new NamedParameterJdbcTemplate(dataSource);
		this.insertAction = new SimpleJdbcInsert(dataSource)
			.withTableName("role");
	}

	public List<RoleDto> selectAll() {
		return jdbc.query(SELECT_ALL, Collections.emptyMap(), rowMapper);
	}

	public int insert(RoleDto dto) {
		SqlParameterSource params = new BeanPropertySqlParameterSource(dto);
		return insertAction.execute(params);
	}

	public int update(RoleDto dto) {
		SqlParameterSource params = new BeanPropertySqlParameterSource(dto);
		return jdbc.update(UPDATE, params);
	}
}
```


##### 검색/삭제

sqls
```java
package com.nts.connect.daoexam.dao;

public class RoleDaoSqls {
	public static final String SELECT_ALL = "SELECT role_id, description FROM role ORDER BY role_id";
	public static final String UPDATE = "UPDATE role SET description = :description WHERE ROLE_ID = :roleId";
	public static final String SELECT_BY_ROLE_ID = "SELECT role_id, description FROM role where role_id = :roleId";
	public static final String DELETE_BY_ROLE_ID = "DELETE FROM role WHERE role_id = :roleId";
}
```


Spring MVC - BE
-------------

### 1) Spring MVC란?

####MVC?
- Model-View-Controller
- Model : 뷰가 렌더링 하는데 필요한 데이터
- View : 웹 어플리케이션에서 뷰는 실제로 보이는 부분, 모델을 사용해 렌더링
- Controller : 사용자의 액션에 응답하는 컴포넌트, 모델을 업데이트하고 다른 액션을 수행

####MVC Model 1 아키텍쳐
![model1](https://i.imgur.com/itZG0t4.png)

브라우저 요청을 JSP가 처리 -> 자바빈을 통해처리
JSP 자체에 자바코드와 HTML태그 혼재 : 유지보수 어려움

#### MVC Model2 아키텍쳐
![model2](https://i.imgur.com/uUk5dqM.png)

서블릿이 요청과 데이터를 처리하는 컨트롤러 역할, JSP가 뷰의 역할 -> 로직과 뷰를 분리

##### MVC Model2 발전형태
![model22](https://i.imgur.com/oslWtfV.png)

클라이언트가 봰는 모든 요청은 프론트 컨트롤러라는 서블릿이 처리, 요청만 받고 처리하지 않고 컨트롤러 클래스(핸들러 클래스)에 위임 : 관련된 URL을 하나의 클래스에서 모두 처리할 수 있게 됬다.
컨트롤러가 처리한 모델(빈)을 프론트 컨트롤러에 보내고 뷰에서 처리하게하고 응답을 보내게 된다.

###### Spring MVC가 Model2를 적용한것이다.
![spring](https://i.imgur.com/s9wMyYd.png)

### Spring MVC 구성요소

#### 학습 목표
1. DispacherServlet이 어떤 순서로 동작하는지 이해한다.
2. DispacherServlet에서 사용되는 컴포넌트(객체)들이 어떤 것들이 있는지 안다.

#### 핵심 개념
- DispacherServlet
- HandlerMapping
- HandlerAdpater
- ViewResolver

#### Spring MVC 기본 동작 흐름

![](https://i.imgur.com/N7e6TKc.png)


1. 클라이언트가 요청을 보내ㅕㅁㄴ Dispatch Servlet이 받아 요청을 처리해줄 컨트롤러가 무엇인지 Handler Mapping에서 정보를 알아낸다.
2. Handler Mapping이 처리할 정보를 xml에서 넣는다.
3. DispatcherServlet이 Handler Adapter를 통해 컨트롤에게 전달
4. Controler가 리턴한 view name을 가ㅣㅈ고 view resolver를 통해 출력한다.
5. View로 응답을 보낸다.


####요청을 위해 사용되는 컴포넌트
DispatcherServlet이 어떻게 동작하는지 알아야 한다.


#### DispatcherServlet
- 프론트 컨트롤러
- 클라이언트의 모든 요청을 받은 후 이를 처리할 핸들러에게 넘기고 핸들러가 처리한 결과를 받아 사용자에게 응답 결과를 보여준다.
- DispatcherServlet은 여러 컴포넌트를 이용해 작업을 처리한다.
- 이론상 여러개 쓸수 있지만 일반적으로 한개만 쓴다.

#### Dispatcher Servlet 내부 동작흐름


