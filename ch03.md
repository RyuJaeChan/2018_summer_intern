Ch3
========


1.JavaScripte - FE
------------------

### 1) 자바스크립트 배열

```javascript
var o = [1, 2,3, 4];
var r = o.concat(2,3); ... ㅣㅇ어 붙인다.
[...o, 2, 3]; concat이랑 똑같다      
```

순회
for문
```javascript
foreach
arr.forEach(function(v,i,0){
    console.log(v);     //엘리먼트 하나씩 출력된다.
    
})
```
```javascript
var mapped = arr.map(fucntion(v){
    return v*2; //각 원소에 *2를 한다.
})
```

### 2) 자바스크립트 객체

dictionary 자료구조
```javascript
var obj = { name : "kim", age : 20 }
```
json 형식과 동일


참고링크
 https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Working_with_Objects#%EA%B0%9D%EC%B2%B4_%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0

obj.name 식으로 접근 가능

순회
```javascript
for(key in obj){     //키 값을 순회하기 위해 쓰는게 좋다.
    console.log(obj[key]);
}

Object.keys(obj) // 키값을 배열 형태로 반환
Object.keys(obj).forEach(fucntion(v){     //forEach로 사용
    console.log(obj[v])
})
```

2. DOM API활용 - FE

1) DOM node의 생성과 추가

활용
Document. https://www.w3schools.com/jsref/dom_obj_document.asp
element. https://www.w3schools.com/jsref/dom_obj_all.asp

유용한 속성

속성들을 변수에 저장할 수 있ㄷ다.
var a = document.querySelector("#nav_tutorials");

a.tagName;
a.innerHTML 하위 엘리먼ㅌ들이 html형식으로 나옴 

firstChild 공백이나 텍스트 포함
firstElementC

삽입예제(appendCHild)
DOM API를 이용하는 표준방법임
var div = document.createElement("div");
var str = ducument.createTextNode("hello");
div.appendChild(str);     //div에 텍슽 추가
$0.appendCHild(div);     //  $0 = 크롬 개발자 도구에서 선택한 엘리먼트에 바로 접근할 수 있는거

React vue 같은거를 통한 템플릿도 있다.

2) 문자열 기반 DOM 처리

문자열 처리 기반으로 처리 DOM을 HTML로 처리
파싱 작업이 브라우저 최적화로 이루어지기 때문에 빠른 방법이다.

var base = document.querySelector(".w3-table-all tr:nth-child(3)");

insertBefore

parent.insetBefore( before, element), parent의 자식인 before의 앞에 element가 들어간다.

HTML을 문자열로 처리해주는 DOM API

parent.innerHTML  // html형태로 가져온다

var html = parent.innerHTML;
parent.innerHTML = "<p>child...</p>";     //코드가 간단히 작성된다.
파싱 작업이 브라우저 최적화로 이루어지기 때문에 빠르다.

$0.innerText +=  "추가할 텍스트";


insertAdjacentHTML

var base = document.querySelector("div");
base.insertAdjacentHTML("atferbegin", "<h2>hello world</h1>");     //para1 넣을 위치의 상수?, para2 인자

var base = document.querySelector("p:nth-child"); 
등등등



실습 거너 뛰고





---------------------------

### 4) HTML templating

웹화면에 데이터를 받아와서 표시한다거나. 웹 하면에 있는 내용을 삭제한다거나 등등 작업을 한다. HTML태그들이 다양하게 변경되어야 하는데 HTML과 데이터를 섞어서 화면에 변경을 주는 방법

HTML Templating 작업이란?
동일한 내용의 리스트들을 비슷한 태그를 이용해 표시하는 경우 여러 태그들을 하나로 묶어서 화면에 추가하는 작업
렌더링을 서버에서하느냐 클라이언트에서 할까는 주요 쟁점 : 적절한 방법을 선택히야 한다.

데이터만 필요할때 받아와서 HTML 테블릿과 결합하여 화면에 추가하는 작업

```javascript
<li>
	<h2>(title)</h2>
<li>

+

{
	title:"my title"
}
```

```javascript
var data={
	title : "my title",
    content : "data text",
    price : 2000
};

var html = "<li><h2>{title}</h2>{content}{price}</li>

//replace를 이용하는 방법
var resultHTML = html.replace("{title}", data.title)
				.replace("{content}", data.content)
				.replace("{price}", data.price)	//method channing
```

### 5) HTML Templating 실습

HTML 템플릿을 어떻게 보관하고 화면에 적용할 수 있는가...


```
var html = "<li><h2>{title}</h2>{content}{price}</li>
```
이런걸 자파스크립트 코드에서 가지고 있는건 좋지 않은 방법이다
- 서버에서 파일로 보관하고 Ajax로 요청해 받아온다.
- HTML 코드안에 숨겨둥다(?)

Templating
HTML 중 script 태그는 type이 javascript가 아니면 렌더링하지 않고 무시한다. 이걸 이용해 템플릿을 숨겨둘 수 있다.
```

//... html 코드들

<script id="template-list-item" type="text/template">	//가져올 템플릿
<li>
	<h2>{title}</h2>
   	<p>{content}</p>
    <div>{price}</div>
</li>
</script>
<script>
	//mock data
	var data=[ {
		title : "my title",
    	content : "data text",
    	price : 2000
	}
    ];

	var template = document.querySelector("teplate-list-item").innerHTML;
    var resultHTML = html.replace("{title}", data.title)
				.replace("{content}", data.content)
				.replace("{price}", data.price)	//method channing

    document.querySelector(".content").innerHTML = resultHTML;
</script>
```
이런 방식으로 가져올 수 있다.

템플릿을 조작하는 방법? replace 말고 뭐가 있을까
템플릿 보관
	간단한건 이렇게 해도 되지만 템플릿 자겅ㅂ을 많이 할 경우 서버단에 템플릿을 만들어 놓고 Ajax로 서버에서 데이터를 받아와서 쓰는방법이있고
    ES6에는 템플릿 리터럴을 쓰면 replace없이 간단히 할 수 있다(모든 브라우저 지원하는건 아님)`

6. Tab UI 실습
-----------------

### 1) Tab UI를 만들기 위한 HTML과 CSS 구조 전략

### 2_ Tab UI에 생명 불어넣기

컴포넌트 : Calandar, 검색창, 숫자버튼 등등
Tab도 이런 컴포넌트 중 하나






7. Spring Core - BE
-------------------

### 1) Spring이란?


### 2) Spring DI/IoC

[참고링크](http://www.nextree.co.kr/p11247/)

#### 컨테이너란?
- 컨테이너는 인스턴스의 생명 주기를 관리한다.
- 생성된 인스턴스들에게 추가적인 기능을 제공한다.

WAS는 메모리를 올린 후 실행한다. 개발자가 작성한 서블릿을 실제 메모리에 올리고 실행하는 WAS가 가지고 있는  서블릿 컨테이너가 실행하는 것이다.

#### IOC란?
- Inversion of Control의 약어
- 개발자는 프로그램의 흐름을 제어하는 코드를 작성한다. 이 흐름의 제어를 개발자가 하는 것이 아니라 다른 프로그램이 하는 것을 IoC라고 한다.

동일한 인터페이스를 통해 사용자가 쓰는 입장에서 동일하게 구현해서 동일한 사용이 가능하도록 제공한다.
스프링이 가지고 있는 BeanFactory와 Application Context가 공장 같은 역할을 해준다.

#### DI란?
- 의존성 주입 받는 방법
- 공장이 만든 인스턴스를 내가 사용할 수 있도록 해주는거
DI는 클래스 사이의 의존관계를 빈(Bean) 설정 정보를 바탕을 ㅗ컨테이너가 자동으로 연결해 주는 것을 말한다.

DI가 적용 안된 예

``` java
class 엔진 {

}

class 자동차 {
     엔진 v = new 엔진();
}
```

DI가 적용된 예
- 엔진 tpye의 v 변수에 아직 인스턴스가 할당되지 앟ㄴ았따.
- 컨테이너가 v변수에 인스턴스를 할당해주게된다.


```java
@Component
class 엔진 {

}

@Component
class 자동차 {
     @Autowired
     엔진 v;
}
```

#### Spring에서 제공하는 IoC/DI 컨테이너
- BeanFactory : IoC/DI에 대한 기본기능을 가지고 있따.
- ApplicatoinConext : BeanFactory의 모든 기능 + 부가기능 : 일반적으로 추천된다.
- BeanPostProcessor는 컨테이너의 기본 로직을 오버라이딩 해서 인스턴스화와 의존성 처리 로직 등을 개발자가 원하는 대로 구현할 수 있게 해주는 것
- BeanFactorypostProcessor 설정 메타 데이터를 커스트마이징
- 공장에서 객체를 만드는데 사용자가 원하는 방법으로 만들어내고 사용하는 것을 도와준다.



### 3) xml파일을 이용한 설정

이클립스 -> file -> New -> maven project 생성
경로 설정 -> Artifact Id : maven-archetype-quickstart 선택
그룹id articact id 설정 -> finish

pom.xml 설정 : jdk 사용을 위한 plugin 추가

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>kr.or.connect</groupId>
  <artifactId>diexam01</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <packaging>jar</packaging>

  <name>diexam01</name>
  <url>http://maven.apache.org</url>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
  </properties>

  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>3.8.1</version>
      <scope>test</scope>
    </dependency>
  </dependencies>
  
-------------------------------------추가----------------------------------------------------
  <build>
     <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.6.1</version>
            <configuration>
                <source>1.8</source>
                <target>1.8</target>
            </configuration>
        </plugin>
    </plugins>
  </build>
----------------------------------------------------------------------------------------------

</project>
```

juint에 빨간줄 나오는거 없애기
problem 탭 -> warning 보면 업데이트하라고 나와있음
project 우클릭 -> maven -> update 하면됨

![프로젝트익스플로러](https://i.imgur.com/miGi2qf.png)

App.java와 AppTest.java를 볼 수 ㅣㅇㅆ다.

![testjava](https://i.imgur.com/JjHmNmE.png)
```
junit.framework.Test;
```
단위 테스트 할 수 있는 도구이다.

![test](https://i.imgur.com/hpwMMgV.png)
저걸 누르면 테스트 할 수 있다.

#### DI 주입하는거 테스트

```java
package com.nts.connect.diexam01;

public class UserBean {

}
```


### 4) JavaConfig를 이용한 설정





8. Spring JDBC - BE
-------------

### 1) Spring JDBC 소개

- jdbc 프로그래밍을 보면 반복되는 개발요소가 있다.
- 스프링 프레임워크가 저수준 세부사항을 처리해준다.
- 개발자는 필요한 부분만 정의

개발자가 할거 : 연결 파라미터 정의, SQL문 지정, 파라미터 선언과 파라미터 값 제공, 각 이터레이션에 대한 작업 수행

#### Spring JDBC 패키지
- org.springframework.jdbc.core : JDBC 템플릿 클래스와 JDBC 템플릿의 다양한 콜백 인터페이스 포함, 추가 관련 클래스 포함
- org.springframework.jdbc.datasource : 데이터 소스 접근을 쉽게하는 유틸리티 클래스와  javaEE 컨테이너 외부에 수정되지 않고 운영되는 JDBC 코드, 테스트에서 사용할 수 있는 간단한 데이터소스 구현체 포함
- org.springframework.jdbc.object : RDBMS의 조회 갱신 저장 프로시저를 스레드 세이프하고 재상용 가능한 객체로 나타내는 클래스 포함
- org.springframework.jdbc.support : SQL Exception 변환 기능과 약간의 유틸리티 클래스

#### JDBC Template

- org.springframework.jdbc.core에서 가장 중요한 클래스입니다.
- 리소스 생성, 해지를 처리해서 연결을 닫는 것을 잊어 발생하는 문제 등을 피할 수 있도록 합니다.
- 스테이먼트(Statement)의 생성과 실행을 처리합니다.
- SQL 조회, 업데이트, 저장 프로시저 호출, ResultSet 반복호출 등을 실행합니다.
- JDBC 예외가 발생할 경우 org.springframework.dao패키지에 정의되어 있는 일반적인 예외로 변환시킵니다.


한건
```java
Actor actor = this.jdbcTemplate.queryForObject(

  "select first_name, last_name from t_actor where id = ?",

  new Object[]{1212L},

  new RowMapper<Actor>() {

    public Actor mapRow(ResultSet rs, int rowNum) throws SQLException {

      Actor actor = new Actor();

      actor.setFirstName(rs.getString("first_name"));

      actor.setLastName(rs.getString("last_name"));

      return actor;

    }

  });
```

여러건 조회
```java
List<Actor> actors = this.jdbcTemplate.query(

  "select first_name, last_name from t_actor",

  new RowMapper<Actor>() {

    public Actor mapRow(ResultSet rs, int rowNum) throws SQLException {

      Actor actor = new Actor();

      actor.setFirstName(rs.getString("first_name"));

      actor.setLastName(rs.getString("last_name"));

      return actor;

    }

  });

```

### 2) Spring JDBC 실습

#### DTO란?
- DataTransfer Object의 약자
- 계층간 데이터 교환을 위한 JavaBeans
- 계층이란 컨트롤러 뷰, 비지니스 계층, 퍼시스턴스 계층
- 로직을 가지고 있지 않은 순수한 데이터 객체

#### DAO란?
- Data Access Object
- 데이터를 조회하거나 조작하는 기능을 전담
- 데이터 베이스를 조작하는 기능을 전담하는 목적

#### ConnectionPool
- 프로그램이 DBMS에 접속하는 시간이 오래 걸린다. : 비용이 크다
- 빠른 접근을 위해 커넥션을 미리 많이 맺어준다.
- 커넥션이 필요하면 커넥션 풀에게 빌려 사용 후 반납한다.
- 커넥션 풀에 사용 가능한 커넥션이 없으면 대기

#### DataSource
- 커넥션 풀을 관리하는 목적으로 사요오디는 객체
- 커넥션을 얻어어고 반납하는 작업


1. 스프링 컨테이너 ApplicationConext config를 읽는다.
2. componentScanAnnotation이 DAO클래스를 찾도록 설정
3. 찾은 모든 DAO 클래스는 스프링 컨테이너가 관리
4. Application Context가 DBConfig 클래스 import
5. DBConfig 클래스는 데이터 소스와 트랜잭션 매니저 객체 생성
6. DAO는 필드로 NamedParameterJdbcTemplate와 SimpleJdbcInsert를 가진다. : DATA Sourece를 필요로한다. SQL 실행을 편리하게 하도록
7. 파라미터와 SQL을 신경써야한다.


#### 실습

1 Maven 프로젝트 생성 -> quickstart
![01](https://i.imgur.com/S8FjH06.png)

2 id 설정하고 finish

3 porm.xml
database, mysql, data source 추가
해주고 maven->update project 실행
```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>com.nts.connect</groupId>
  <artifactId>daoexam</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <packaging>jar</packaging>

  <name>daoexam</name>
  <url>http://maven.apache.org</url>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <!-- 버전 관리를 위해 상수처럼 쓸 수 있도록-->
    <!-- ${spring.version} 이렇게 사용 가능-->
    <spring.version>4.3.5.RELEASE</spring.version>
  </properties>

  <dependencies>
  <!-- Spring -->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-context</artifactId>
			<version>${spring.version}</version>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-jdbc</artifactId>
			<version>${spring.version}</version>
		</dependency>

		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-tx</artifactId>
			<version>${spring.version}</version>
		</dependency>

		<!-- basic data source -->
		<dependency>
			<groupId>org.apache.commons</groupId>
			<artifactId>commons-dbcp2</artifactId>
			<version>2.1.1</version>
		</dependency>

		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<version>5.1.45</version>
		</dependency>
		
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>3.8.1</version>
      <scope>test</scope>
    </dependency>
  </dependencies>
  <!-- JRE 1.8로 -->
  <build>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<version>3.6.1</version>
				<configuration>
					<source>1.8</source>
					<target>1.8</target>
				</configuration>
			</plugin>
		</plugins>
	</build>
</project>
```

4 ApplicationConfig 클래스 생성
```java
package com.nts.connect.daoexam.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

@Configuration //config라고 명시 실행되면서 여기 설정에 대한 정보를 읽을 수 있다.
@ComponentScan(basePackages = {"com.nts.connect.daoexam.dao"}) //Bean등록 방법으로 Annotation을 했으니 이걸 추가해야한다. 패키지를 여러개 나열할 수있다.
@Import({DBConfig.class}) //설정 파일을 여러개로 나누어서 사용할 수 있다.
public class ApplicationConfig {

}
```


5 테스트코드 실행
```java
package com.nts.connect.daoexam.main;

import java.sql.Connection;

import javax.sql.DataSource;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

import com.nts.connect.daoexam.config.ApplicationConfig;

public class DataSourceTest {

	public static void main(String[] args) {
		ApplicationContext ac = new AnnotationConfigApplicationContext(ApplicationConfig.class);
		DataSource ds = ac.getBean(DataSource.class);

		try (Connection conn = ds.getConnection()) {
			if (conn != null) {
				System.out.println("접속 성공^^");
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

}
```
---

###### 테스트 오류
maven dependencies가 충돌이 일어나서 그런듯

![03](https://i.imgur.com/cBvuP2b.png)

패키지에 빨간줄 뜨면서 안됨
```
The type org.springframework.context.support.GenericApplicationContext cannot be resolved. It is indirectly referenced from required .class files
```

이클립스 끄고
```
C:\Users\USER\.m2\repository\org
```
에서 spingframework 지우고 다시 이클립스 들어가서 maven update



#### query select 실습

DTO 생성
```java
package com.nts.connect.daoexam.dto;

public class Role {
	private int roleId;
	private String description;

	public int getRoleId() {
		return roleId;
	}

	public void setRoleId(int roleId) {
		this.roleId = roleId;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}
    @Override
	public String toString() {
		return "Role [roleId=" + roleId + ", description=" + description + "]";
	}
}
```

RoleDaoSqls

```java
package com.nts.connect.daoexam.dao;

public class RoleDaoSqls {
	public static final String SELECT_ALL = "SELECT role_id, description FROM role ORDER BY role_id";
}

```

```java
package com.nts.connect.daoexam.dao;

import static com.nts.connect.daoexam.dao.RoleDaoSqls.SELECT_ALL;

import java.util.Collections;
import java.util.List;

import javax.sql.DataSource;

import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.simple.SimpleJdbcInsert;
import org.springframework.stereotype.Repository;

import com.nts.connect.daoexam.dto.Role;

@Repository
public class RoleDao {
	private NamedParameterJdbcTemplate jdbc;
	private SimpleJdbcInsert insertAction;
	private RowMapper<Role> rowMapper = BeanPropertyRowMapper.newInstance(Role.class);

	public RoleDao(DataSource dataSource) {
		this.jdbc = new NamedParameterJdbcTemplate(dataSource);
		this.insertAction = new SimpleJdbcInsert(dataSource)
			.withTableName("role");
	}

	public List<Role> selectAll() {
		return jdbc.query(SELECT_ALL, Collections.emptyMap(), rowMapper);
	}

}
```

Select All Test
```java
package com.nts.connect.daoexam.main;

import java.util.List;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

import com.nts.connect.daoexam.config.ApplicationConfig;
import com.nts.connect.daoexam.dao.RoleDao;
import com.nts.connect.daoexam.dto.Role;

public class SelectAllTest {

	public static void main(String[] args) {
		ApplicationContext ac = new AnnotationConfigApplicationContext(ApplicationConfig.class);

		RoleDao roleDao = ac.getBean(RoleDao.class);

		List<Role> list = roleDao.selectAll();

		for (Role element : list) {
			System.out.println(element);
		}
	}

}
```

###### 근데 role_id가 roleID로 자동으로 변환되는데 DB필드에 role_id와 roleId가 같이있으면 어떻게 될까?

```
+---------+--------+-------------+
| role_id | roleId | description |
+---------+--------+-------------+
|   10001 | 200001 | hello       |
|   10002 | 200002 | hello11     |
|   10003 | 200003 | world       |
+---------+--------+-------------+
```

```
RoleDto [roleId=0, role_id=10001, description=hello]
RoleDto [roleId=0, role_id=10002, description=hello11]
RoleDto [roleId=0, role_id=10003, description=world]
```
roleId는 아예 처리하지 않는 것을 볼 수 있다.


##### query insert 실습


dao에 insert 메소드 정의
```java
package com.nts.connect.daoexam.dao;

import static com.nts.connect.daoexam.dao.RoleDaoSqls.SELECT_ALL;

import java.util.Collections;
import java.util.List;

import javax.sql.DataSource;

import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.jdbc.core.simple.SimpleJdbcInsert;
import org.springframework.stereotype.Repository;

import com.nts.connect.daoexam.dto.RoleDto;

@Repository
public class RoleDao {
	private NamedParameterJdbcTemplate jdbc;
	private SimpleJdbcInsert insertAction;
	private RowMapper<RoleDto> rowMapper = BeanPropertyRowMapper.newInstance(RoleDto.class);

	public RoleDao(DataSource dataSource) {
		this.jdbc = new NamedParameterJdbcTemplate(dataSource);
		this.insertAction = new SimpleJdbcInsert(dataSource)
			.withTableName("role");
	}

	public List<RoleDto> selectAll() {
		return jdbc.query(SELECT_ALL, Collections.emptyMap(), rowMapper);
	}

	public int insert(RoleDto dto) {
		SqlParameterSource params = new BeanPropertySqlParameterSource(dto);
		return insertAction.execute(params);
	}
}
```

테스트 코드
```java
package com.nts.connect.daoexam.main;

import java.util.List;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

import com.nts.connect.daoexam.config.ApplicationConfig;
import com.nts.connect.daoexam.dao.RoleDao;
import com.nts.connect.daoexam.dto.RoleDto;

public class TestMain {

	public static void main(String[] args) {
		ApplicationContext ac = new AnnotationConfigApplicationContext(ApplicationConfig.class);

		RoleDao roleDao = ac.getBean(RoleDao.class);

		List<RoleDto> list = roleDao.selectAll();

		for (RoleDto element : list) {
			System.out.println(element);
		}

		RoleDto role = new RoleDto();
		role.setRoleId(100);
		role.setDescription("insert test");

		int cnt = roleDao.insert(role);
		System.out.println("cnt : " + cnt);

		list = roleDao.selectAll();

		for (RoleDto element : list) {
			System.out.println(element);
		}
	}

}

```

##### Update 싫습


dao에 update 메소드 추가

```java
package com.nts.connect.daoexam.dao;

import static com.nts.connect.daoexam.dao.RoleDaoSqls.SELECT_ALL;
import static com.nts.connect.daoexam.dao.RoleDaoSqls.UPDATE;

import java.util.Collections;
import java.util.List;

import javax.sql.DataSource;

import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.jdbc.core.simple.SimpleJdbcInsert;
import org.springframework.stereotype.Repository;

import com.nts.connect.daoexam.dto.RoleDto;

@Repository
public class RoleDao {
	private NamedParameterJdbcTemplate jdbc;
	private SimpleJdbcInsert insertAction;
	private RowMapper<RoleDto> rowMapper = BeanPropertyRowMapper.newInstance(RoleDto.class);

	public RoleDao(DataSource dataSource) {
		this.jdbc = new NamedParameterJdbcTemplate(dataSource);
		this.insertAction = new SimpleJdbcInsert(dataSource)
			.withTableName("role");
	}

	public List<RoleDto> selectAll() {
		return jdbc.query(SELECT_ALL, Collections.emptyMap(), rowMapper);
	}

	public int insert(RoleDto dto) {
		SqlParameterSource params = new BeanPropertySqlParameterSource(dto);
		return insertAction.execute(params);
	}

	public int update(RoleDto dto) {
		SqlParameterSource params = new BeanPropertySqlParameterSource(dto);
		return jdbc.update(UPDATE, params);
	}
}
```


##### 검색/삭제

sqls
```java
package com.nts.connect.daoexam.dao;

public class RoleDaoSqls {
	public static final String SELECT_ALL = "SELECT role_id, description FROM role ORDER BY role_id";
	public static final String UPDATE = "UPDATE role SET description = :description WHERE ROLE_ID = :roleId";
	public static final String SELECT_BY_ROLE_ID = "SELECT role_id, description FROM role where role_id = :roleId";
	public static final String DELETE_BY_ROLE_ID = "DELETE FROM role WHERE role_id = :roleId";
}
```


9. Spring MVC - BE
-------------

### 1) Spring MVC란?

#### MVC?
- Model-View-Controller
- Model : 뷰가 렌더링 하는데 필요한 데이터
- View : 웹 어플리케이션에서 뷰는 실제로 보이는 부분, 모델을 사용해 렌더링
- Controller : 사용자의 액션에 응답하는 컴포넌트, 모델을 업데이트하고 다른 액션을 수행

#### MVC Model 1 아키텍쳐
![model1](https://i.imgur.com/itZG0t4.png)

브라우저 요청을 JSP가 처리 -> 자바빈을 통해처리
JSP 자체에 자바코드와 HTML태그 혼재 : 유지보수 어려움

#### MVC Model2 아키텍쳐
![model2](https://i.imgur.com/uUk5dqM.png)

서블릿이 요청과 데이터를 처리하는 컨트롤러 역할, JSP가 뷰의 역할 -> 로직과 뷰를 분리

##### MVC Model2 발전형태
![model22](https://i.imgur.com/oslWtfV.png)

클라이언트가 봰는 모든 요청은 프론트 컨트롤러라는 서블릿이 처리, 요청만 받고 처리하지 않고 컨트롤러 클래스(핸들러 클래스)에 위임 : 관련된 URL을 하나의 클래스에서 모두 처리할 수 있게 됬다.
컨트롤러가 처리한 모델(빈)을 프론트 컨트롤러에 보내고 뷰에서 처리하게하고 응답을 보내게 된다.

###### Spring MVC가 Model2를 적용한것이다.
![spring](https://i.imgur.com/s9wMyYd.png)

### 2)Spring MVC 구성요소

#### 학습 목표
1. DispacherServlet이 어떤 순서로 동작하는지 이해한다.
2. DispacherServlet에서 사용되는 컴포넌트(객체)들이 어떤 것들이 있는지 안다.

#### 핵심 개념
- DispacherServlet
- HandlerMapping
- HandlerAdpater
- ViewResolver

#### Spring MVC 기본 동작 흐름

![](https://i.imgur.com/N7e6TKc.png)


1. 클라이언트가 요청을 보내ㅕㅁㄴ Dispatch Servlet이 받아 요청을 처리해줄 컨트롤러가 무엇인지 Handler Mapping에서 정보를 알아낸다.
2. Handler Mapping이 처리할 정보를 xml에서 넣는다.
3. DispatcherServlet이 Handler Adapter를 통해 컨트롤에게 전달
4. Controler가 리턴한 view name을 가ㅣㅈ고 view resolver를 통해 출력한다.
5. View로 응답을 보낸다.


#### 요청을 위해 사용되는 컴포넌트
DispatcherServlet이 어떻게 동작하는지 알아야 한다.


#### DispatcherServlet
- 프론트 컨트롤러
- 클라이언트의 모든 요청을 받은 후 이를 처리할 핸들러에게 넘기고 핸들러가 처리한 결과를 받아 사용자에게 응답 결과를 보여준다.
- DispatcherServlet은 여러 컴포넌트를 이용해 작업을 처리한다.
- 이론상 여러개 쓸수 있지만 일반적으로 한개만 쓴다.

#### Dispatcher Servlet 내부 동작흐름

![0002](https://i.imgur.com/yBJTFL2.png)

- 요청이 들어오면 요청 선처리 작업 : 그냥 처리하는게 아니라 작업을 거치낟
- HandlerExecutionChain 결정
- HanderExecutionChain 실행
- 예외?
- 뷰렌더링
- 요청처리
- 요청처리 종료

##### 요청 선처리 작업
![0001](https://i.imgur.com/jSjqm3P.png)

- Locale 결정 : 지역화? 브라우저 언어 세팅에 따라 결정
- RequestContextHolder에 요청 저장 : 스레드 로컬 객체로 요청을 받아 처리할 때까지 Spring이 관리하는 객체안에서 사용할 수 있도록 저장 - 아주 권장하는 방법은 아니다. 스프링에서  HttpServletRequest 제공하는걸 쓰자
- FlashMap : 리다이렉트로 전달하는 값을 유지하도록
- 멀티파트요청? : 파일 정보를 읽을때는 특수한 요청을 처리해야한다.
- 핸들러 결정과 실행한다.

사용되는 컴포넌트
- org.springframework.web.servlet.LocaleResolver
 - 지역 정보를 결정해주는 전략 오브젝트이다.
 - 디폴트인 AcceptHeaderLocalResolver는 HTTP 헤더의 정보를 보고 지역정보를 설정해준다.
org.springframework.web.servlet.FlashMapManager
 - FlashMap객체를 조회(retrieve) & 저장을 위한 인터페이스
 - RedirectAttributes의 addFlashAttribute메소드를 이용해서 저장한다.
 - 리다이렉트 후 조회를 하면 바로 정보는 삭제된다.
- org.springframework.web.context.request.RequestContextHolder
 - 일반 빈에서 HttpServletRequest, HttpServletResponse, HttpSession 등을 사용할 수 있도록 한다.
 - 해당 객체를 일반 빈에서 사용하게 되면, Web에 종속적이 될 수 있다.
- org.springframework.web.multipart.MultipartResolver
 - 멀티파트 파일 업로드를 처리하는 전략

##### 요청 전달

![](https://i.imgur.com/YBXvJwj.png)


- HandlerMapping으로 Chain결정
- Chain 발견?
 - 못하면 Http 404전달
- Adapter 발견?
 - 못하면 ServletExecption 발생
- 요청 처리

요청전달시 사용된 컴포넌트
- HandlerMapping
 - 어떤 핸들러가 요청을 처리할지에 대한 정보를 알고있따.
 - 디폴트로 BeanNameHandlerMapping과 DefaultAnnotationHandlerMapping이 설정되어있다.
- HandlerExecutionChain
 - 실제로 호출된 핸들러에 대한 참도를 가지고 있다.
 - 무엇이 실행되어야 할지 알고 있는 객체 : 핸들러 실행전과 실행후에 수행될 HandlerInterceptor도 참조하고 있음
- HandlerAdapter
 - 실제 핸들러를 실행하는 역할
 - 선택된 핸들러를 실행하는 방법과 응답을 ModelAndView로 변화하는 방법에 대해 알고 있다.
 - HttpRequestHandlerAdapter, SimpleControllerHandlerAdapter, AnnotationMethodHanderAdapter 3가지가 디폴트로 설정된 핸들러어댑터
 - @RequestMapping @Controller를 통해 정의된 컨트롤러의 경우DefaultAnnotationHandlerMapping에 의해 핸들러가 결정되고, 그에 대응하는 AnnotationmethodHandlerAdapter에 의해 호출이 일어난다.

##### 요청 처리

Chain이 결정되면 사용 가능한 인터셉터가 있나 찾는다 : 인터셉더는 챕터5쯤에 다시
인터셉터는 일종의 필터

![](https://i.imgur.com/YRHKltN.png)

- 사용가능한 ㅣㅇㄴ터셉터가 존재? : 요청처리
- 핸들러실행

요청시 사용되는 컴포넌트
- ModelAndView
 - Controller의 처리 결과를 보여줄 view와 view에서 사용할 값을 전달하는 클래스 : 서블릿에서 쓴 request에 값넣어서 쓴거 같은거
- RequestToViewNameTranslator
 - 컨트롤러에서 뷰 ㅣㅇ름이나 뷰 오브젝트를 제공해주지 않았을 경우 URL과 같은 요청정보를 참고해 자동으로 뷰 이름을 생성해 주는 전략 오브젝트
 - 디폴트는 DefaultRequestToViewNameTranslator


##### 예외처리

![](https://i.imgur.com/CzAX5E6.png)

사용된 컴포넌트
- HandlerExceptionResolver
 - 기본적으로 DispatcherServlet이 DefaultHandlerExceptoinResolver를 등록
 - 예뢰가 전져졌을 때 어떤 핸들러를 실행할 것인지에 대한 정보를 제공


##### 뷰 렌더링

![](https://i.imgur.com/85Pi6aN.png)

- 구현체를 찾을 수 업승면 ServletException 던짐

뷰 렌더링 과정시 사용된 컴포넌트
- ViewResolver
 - 컨트롤러가 리턴한 뷰 이름을 참고해서 적절한 오브젝트를 찾아주는 로직을 가진 전략 오브젝트
 - 뷰의 종류에 따라 적절한 ViewResolver를 추가로 설정할 수 있다.

##### 요청 처리 종료

![](https://i.imgur.com/NC0Ei3W.png)


### 3)Spring MVC를 이용한 웹 페이지 작성 실습

#### 학습 목표
- Spring MVC를 이용해 프로젝트를 구성할 수 있고, 개발자가 작성해야 할 파일이 무엇인지 이해한다.
- Spring MVC를 이용해 웹 어플리케이션을 작성할 수 있다.

#### 핵심 개념
- DispacherServlet
- WebApplicationInitializer
- @RequestMapping = @GetMapping = @PostMapping

#### Controller작성 실습 1/3

- 웹 브라우저에서 http://localhost:8080/mvcexam/plusform 이라고 요청을 보 내면 서버는 웹 브라우저에게 2개의 값을 입력받을 수 있는 입력 창과 버튼이 있는 화면을 출력한다.
- 웹 브라우저에 2개의 값을 입력하고 버튼을 클릭하면 http://localhost:8080/mvcexam/plus URL로 2개의 입력값이 POST방식으로 서버에게 전달한다. 서버는 2개의 값을 더한 후, 그 결과 값을 JSP에게 request scope으로 전달하여 출력한다.

maven webapp 생성 후 porm.xml 수정
```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<groupId>com.nts.connect</groupId>
	<artifactId>mvcexam</artifactId>
	<packaging>war</packaging>
	<version>0.0.1-SNAPSHOT</version>
	<name>mvcexam Maven Webapp</name>
	<url>http://maven.apache.org</url>

	<!-- Properties Setting -->
	<properties>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		<spring.version>4.3.5.RELEASE</spring.version>
	</properties>

	<dependencies>
		<!-- Spring -->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-context</artifactId>
			<version>${spring.version}</version>
		</dependency>
		<!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-webmvc</artifactId>
			<version>${spring.version}</version>
		</dependency>
		
		
		
		<!--  Servlet and JSTL -->
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>javax.servlet-api</artifactId>
			<version>3.1.0</version>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>jstl</artifactId>
			<version>1.2</version>
		</dependency>
		
		<!--  JUNIT -->
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>4.12</version>
			<scope>test</scope>
		</dependency>
	</dependencies>
	<build>
		<finalName>mvcexam</finalName>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<version>3.6.1</version>
				<configuration>
					<source>1.8</source>
					<target>1.8</target>
				</configuration>
			</plugin>
		</plugins>
	</build>
</project>


```

네비게이터 .setting에서 Servlet 3.1로
![](https://i.imgur.com/LUVpqfS.png)


#### DispatcherServlte을 FrontController로 설정하기

- frontcontroller 역할을 하도록 설정을 해줘야한다.
- web.xml 파일에 설정	<- 가장많이
- ServletContainerInitializer 사용
 - 서블릿 3.0 스펙 이상에서 web.xml을 대신해서 사용할 수 있다.
- WebApplicationInitializer 인터페이스를 구현해 사용 <- 가장많이


##### web.xml 파일에서 설정
- xml spring 설정을 읽어들이도록 DispatcherServlet 설정


url pattern을 /로 하면 모든 요청을 받게 된다.

##### WebApplicationInitializer를 구현해서 설정
- 단점 : 초기화 할 때 오래 걸릴 수 있따. : SpringMVC가 WebApplicationInitializer 인터페이스를 구현한 구현체를 찾고 해당 객채으 ㅣonStartup메소드를 이용해 초기화를 하기 때문에

이렇게도 하는구나 소개만 합니다.


##### Spring MVC 설정

![](https://i.imgur.com/xrvBqpz.png)

@Configuration : 자바 Config파일임을 알림

@EnableWebMvc
- 웹에 필요한 빈을 자동으로 설정해준다.
- xml로 설정의 <mvc:annotation-driven/>와 동일하다 <- 잘 안쓰는 방법
- 기볼 설정 이외의 설정이 필요하면 WebMvcConfigurerAdapter를 상속받도록 Javaconfig class를 작성한 후, 필요한 메소드를 오버라이딩하도록 한다.

![](https://i.imgur.com/gLB2fYf.png)

WWebMvcConfigurationSuppert를 상속받아 하고있다.

@ComponentScan
- 어떤 애가 controller, Service, Repository, Component 애노테이션이 붙은 클래스를 찾아 스프링 컨테이너가 관리하게 된다.
- ComponentScan애노테이션을 이용하면 Controller, Service, Repository, Component애노테이션이 붙은 클래스를 찾아 스프링 컨테이너가 관리하게 된다.
- DefaultAnnotationHandlerMapping과 RequestMappingHandlerMapping구현체는 다른 핸드러 매핑보다 훨씬 더 정교한 작업을 수행한다. 이 두 개의 구현체는 애노테이션을 사용해 매핑 관계를 찾는 매우 강력한 기능을 가지고 있다. 이들 구현체는 스프링 컨테이너 즉 애플리케이션 컨텍스트에 있는 요청 처리 빈에서 RequestMapping애노테이션을 클래스나 메소드에서 찾아 HandlerMapping객체를 생성하게 된다.
 - HandlerMapping은 서버로 들어온 요청을 어느 핸들러로 전달할지 결정하는 역할을 수행한다.
- DefaultAnnotationHandlerMapping은 DispatcherServlet이 기본으로 등록하는 기본 핸들러 맵핑 객체이고, RequestMappingHandlerMapping은 더 강력하고 유연하지만 사용하려면 명시적으로 설정해야 한다.


##### WwebMvcConfigurerAdapter
@EnableWebMvc를 이용하면 기본적인 설정이 모두 자동으로 되지만, 기본 설정 이외이ㅡ 설정이 필요할 경우 해당 클래스를 상속 받은 후, 메소드를 오버라이딩 하여 구현한다.

##### Controller(Handler) 클래스 작성하기

- @Controller 애노테이션을 클래스 위에 붙인다.
- 매핑을 위해 @RequestMapping 애노테이션을 클래스나 메소드에서 사용한다. : 실제로 처리하는 컨트롤러가 뭔지 찾기 위해

##### @RequestMapping
- http 요청고 ㅏ이를 다루기 위한 Controller의 메소드를 연결하는 어노테이션
- 방법
 - @RequestMapping("/users", method=RequestMethod.POST)
 - From Spring 4.3ver
  - GetMapping
  - PostMapping
  - PutMapping
  - DeleteMapping
  - PatchMapping
- Http 특정 해더와 연결하는 방법
 - @RequestMapping(method = RequestMethod.GET, headers = "content-type=application/json")
- Http Parameter 와 연결하는 방법
 - @RequestMapping(method = RequestMethod.GET, params = "type=raw")
- Content-Type Header 와 연결하는 방법
 - @RequestMapping(method = RequestMethod.GET, consumes = "application/json")
- Accept Header 와 연결하는 방법
 - @RequestMapping(method = RequestMethod.GET, produces = "application/json")


WebMvcContextConfiguration 클래스 생성

```java
package com.nts.connect.mvcexam.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;
import org.springframework.web.servlet.view.InternalResourceViewResolver;

@Configuration
@EnableWebMvc
@ComponentScan(basePackages = {"com.nts.connect.mvcexam.controller"})
public class WebMvcContextConfiguration extends WebMvcConfigurerAdapter {

	//css나 js 등 다른 요청들이 왔을때도 /로 매핑되어버리기 때문에 그 부분을 처리
	@Override
	public void addResourceHandlers(ResourceHandlerRegistry registry) {
		registry.addResourceHandler("/assets/**").addResourceLocations("classpath:/META-INF/resources/webjars/")
			.setCachePeriod(31556926);
		registry.addResourceHandler("/css/**").addResourceLocations("/css/").setCachePeriod(31556926);
		registry.addResourceHandler("/img/**").addResourceLocations("/img/").setCachePeriod(31556926);
		registry.addResourceHandler("/js/**").addResourceLocations("/js/").setCachePeriod(31556926);
	}

	// default servlet handler를 사용하게 합니다.
	// 매핑 정보가 없는 요청은 여기서 처리하도록 한다.
	@Override
	public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
		configurer.enable();
	}

	//특정 url에 대한 처리를 컨트로러 클래스를 작성하지 않고 매핑할 수 있도록
	@Override
	public void addViewControllers(final ViewControllerRegistry registry) {
		System.out.println("addViewControllers가 호출됩니다. ");
		registry.addViewController("/").setViewName("main"); // /요청을 main 뷰로
	}

	//뷰 정보를 지정
	@Bean
	public InternalResourceViewResolver getInternalResourceViewResolver() {
		InternalResourceViewResolver resolver = new InternalResourceViewResolver();
		resolver.setPrefix("/WEB-INF/views/");
		resolver.setSuffix(".jsp");
		return resolver;
	}
}
```

DispatcherServlet을 fontController로 설정해야한다.
web.xml에 내용 추가해야함

```xml
<?xml version="1.0" encoding="UTF-8"?>

<web-app>
  <display-name>Archetype Created Web Application</display-name>
  <servlet>
    <servlet-name>mvc</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
      <param-name>contextClass</param-name>
      <param-value>org.springframework.web.context.support.AnnotationConfigWebApplicationContext</param-value>
    </init-param>
    <init-param>
      <param-name>contextConfigLocation</param-name>
      <param-value>com.nts.connect.mvcexam.config.WebMvcContextConfiguration</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
  </servlet>
  <servlet-mapping>
    <servlet-name>mvc</servlet-name>
    <url-pattern>/</url-pattern>
  </servlet-mapping>
</web-app>
```

##### Controller 작성 실습

jsp 2개 작성

plusform.jsp

```xml
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Plus Form</title>
</head>
<body>
<form method="post" action="plus">  
value1 : <input type="text" name="value1"><br>
value2 : <input type="text" name="value2"><br>
<input type="submit" value="확인">  
</form>  
</body>
</html>
```

plusResult.jsp

```xml
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Plus Result</title>
</head>
<body>
${value1} 더하기 ${value2} (은/는) ${result} 입니다.
</body>
</html>
```


Contoller 작성
```java
package com.nts.connect.mvcexam.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.ModelMap;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;

@Controller //controller임을 명시한다.
public class PlustController {
	@GetMapping(path = "plusForm")
	//ModelAndView로해도 되고 여기는 간단하니 String으로
	public String plusform() {
		//요청이 들어왔을때 저 view를 보여줘여요
		//view만 찾아서 넘겨주면 됨
		return "plusForm"; //이름만 넘겨준다. 설정에서 resolver가 .jsp붙이고 WEB-INF/view/를 붙인다.
	}

	@PostMapping(path = "plus")
	//Spring MVC는 Controller 메소드 인수로 다양한 인수 타입을 제공하기 때문에 잘 보고 할 수 있다.
	public String plus(@RequestParam(name = "value1", required = true) int value1,
		@RequestParam(name = "value2", required = true) int value2, ModelMap modelMap) {
		int result = value1 + value2;

		//스프링이 알아서 request scope에 지정한다.
		modelMap.addAttribute("value1", value1);
		modelMap.addAttribute("value2", value2);
		modelMap.addAttribute("result", result);
		return "plusResult";
	}
}
```

###### @RequestParam
- Mapping된 메소드의 Argument에 붙일 수 있는 어노테이션
- @RequestParam의 name에는 http parameter의 name과 멥핑
- @RequestParam의 required는 필수인지 아닌지 판단

###### @PathVariable
- @RequestMapping의 path에 변수명을 입력받기 위한 place holder가 필요함
- place holder의 이름과 PathVariable의 name 값과 같으면 mapping 됨
- required 속성은 default true 임

###### @RequestHeader
- 요청 정보의 헤더 정보를 읽어들 일 때 사용
- @RequestHeader(name="헤더명") String 변수명

###### Spring MVC가 지원하는 메소드 리턴 값
- org.springframework.web.servlet.ModelAndView
- org.springframework.ui.Model
- java.util.Map
- org.springframework.ui.ModelMap
- org.springframework.web.servlet.View
- java.lang.String
- java.lang.Void
- org.springframework.http.HttpEntity<?>
- org.springframework.http.ResponseEntity<?>
- 기타 리턴 타입 ...


plusform ...

![](https://i.imgur.com/H7Eynsm.png)


plus ...

![](https://i.imgur.com/Xcc7Rii.png)



#### Controller작성 실습 2/3
- http://localhost:8080/mvcexam/userform 으로 요청을 보내면 이름, email, 나이를 물어보는 폼이 보여진다.
- 폼에서 값을 입력하고 확인을 누르면 post방식으로 http://localhost:8080/mvcexam/regist 에 정보를 전달하게 된다.
- regist에서는 입력받은 결과를 콘솔 화면에 출력한다.

#### Controller작성 실습 3/3

- http://localhost:8080/mvcexam/goods/{id} 으로 요청을 보낸다.
- 서버는 id를 콘솔에 출력하고, 사용자의 브라우저 정보를 콘솔에 출력한다.
- 서버는 HttpServletRequest를 이용해서 사용자가 요청한 PATH정보를 콘솔에 출력한다.



