Ch3
========


1.JavaScripte - FE
------------------

### 1) 자바스크립트 배열

```javascript
var o = [1, 2,3, 4];
var r = o.concat(2,3); ... ㅣㅇ어 붙인다.
[...o, 2, 3]; concat이랑 똑같다
```

순회
for문
```javascript
foreach
arr.forEach(function(v,i,0){
    console.log(v);     //엘리먼트 하나씩 출력된다.
})
```
```javascript
var mapped = arr.map(fucntion(v){
    return v*2; //각 원소에 *2를 한다.
})
```

### 2) 자바스크립트 객체

dictionary 자료구조
```javascript
var obj = { name : "kim", age : 20 }
```
json 형식과 동일


참고링크
 https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Working_with_Objects#%EA%B0%9D%EC%B2%B4_%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0

obj.name 식으로 접근 가능

순회
```javascript
for(key in obj){     //키 값을 순회하기 위해 쓰는게 좋다.
    console.log(obj[key]);
}

Object.keys(obj) // 키값을 배열 형태로 반환
Object.keys(obj).forEach(fucntion(v){     //forEach로 사용
    console.log(obj[v])
})
```


## 2. DOM API활용 - FE
------------------------

### 1) DOM node의 생성과 추가

##### 활용
Document. https://www.w3schools.com/jsref/dom_obj_document.asp
element. https://www.w3schools.com/jsref/dom_obj_all.asp

#### 유용한 속성

속성들을 변수에 저장할 수 있다.
```javascript
var a = document.querySelector("#nav_tutorials");
```
a.tagName;
a.innerHTML 하위 엘리먼ㅌ들이 html형식으로 나옴


firstChild 공백이나 텍스트 포함
firstElementC

#### 삽입예제(appendCHild)
DOM API를 이용하는 표준방법임
```javascript
var div = document.createElement("div");
var str = ducument.createTextNode("hello");
div.appendChild(str);     //div에 텍슽 추가
$0.appendCHild(div);     //  $0 = 크롬 개발자 도구에서 선택한 엘리먼트에 바로 접근할 수 있는거
```

React vue 같은거를 통한 템플릿도 있다.

### 2) 문자열 기반 DOM 처리

문자열 처리 기반으로 처리 DOM을 HTML로 처리
파싱 작업이 브라우저 최적화로 이루어지기 때문에 빠른 방법이다.
```javascript
var base = document.querySelector(".w3-table-all tr:nth-child(3)");
```

###### insertBefore
parent.insetBefore( before, element), parent의 자식인 before의 앞에 element가 들어간다.

###### HTML을 문자열로 처리해주는 DOM API

```javascript
parent.innerHTML  // html형태로 가져온다

var html = parent.innerHTML;
parent.innerHTML = "<p>child...</p>";     //코드가 간단히 작성된다.
파싱 작업이 브라우저 최적화로 이루어지기 때문에 빠르다.

$0.innerText +=  "추가할 텍스트";
```

###### insertAdjacentHTML

```javascript
var base = document.querySelector("div");
base.insertAdjacentHTML("atferbegin", "<h2>hello world</h1>");     //para1 넣을 위치의 상수?, para2 인자

var base = document.querySelector("p:nth-child");
등등등
```


실습 거너 뛰고


3. Ajax
-----------

var jsonobj = JSON.parse(this.responseText); 를 통해 response를 object로 바꿔 json처럼 다룰 수 있다.
```javascript
var name = jsonobj.name;

var outside = documetn.querySelector(".outside");
outside.innerHTML += "<span>"+name+"</span>"
```

###### cross domain 문제

A 도메인에서 B도메인으로 데이터를 요청할 수 없다. 이를 회피하기 위해 CORS라는 방법을 이용한다. (ex 네이버 메인에서 검색엔진 도메인으로 데이터를 넘겨준다)
허용 가능한 도메인을 등록하는 과정
JSONP라는 방식도 널리 사용되고 있고 최근에는 CORS라는 표준 방법이 제공되고 있다.


크롬개발자도구의 network 탭을 통해 정보를 확인할 수있다.

검색어추천할 떄 network탭에서 확인 안되면 jsonp 방식을 이용하는 거다.


###### Debugging

크롬 개발자 도구를 이용한 디버깅
서버 통신은 코드상으로 디버그 하기 어렵기 때문에 개발자도구의 network탭을 확인한다.



4. Web Animation - FE
----------------------

### 1) 웹 애니메이션 이해와 setTimeout 활용

1초에 60프레임이 나와야 매끄러움 (16.666ms)

CSS-의 transition 속성으로 할수있따
간단하고 규칙인거 -> CSS로
세밀한 조작이 필요하니거 -> JavaScript로

- setInterval
    정해진 시간마다 함수가 실행 된다고 보장할 수 없다. 비동기 작업이기 때문에 다른 작업이 있을 경우 이후에 실행될 가능성이있따

- setTimeout
    지정된 시간이후 한번만 실행된다 -> 재귀형식으로 구현
```javascript
let count = 0;
function animate(){
    setTimeout(() => {
          if(count >= 20) return;
          console.log("dd");
         count++;
          animate();
    }, 500;
}
animate();
```
=> 명확하게 순차적으로 실행된다.
하지만 이것도 최적화된 방법은 아니다.
대안으로 requestAnimationFrame 탄생

-request

### 2)requestAnimationFrame

최적화해서 렌더링하게 제공되는 함수

```javascript
var count = 50;
var el=doucument.querySelector(".outside");
el.style.left = "0px";
function run(){
    if(count > 50) return;
    count += 5;
    el.style.left = parseInt(el.style.left) + count + "px";
     requestAnimationFrame(run);
}
requestAnimationFrame(run);
```


### 3) CSS3 transition 활용

이 방법이 JavaScript로 구현하는 것 보다 빠르다고 알려져 있다.

transform: all 2s // //; <- 모든 변화가 애니메이션이 된다.
여기에 ease-in ease, ease-out 등 속성을 넣을수도 있다.

메인 스레드를 방해하지 앟ㄴ는GPU가속을 할 수 있는 속성들도 있다.

```
scale :
rotate
opacity
translateXXX
```

transition은 브라우저 지원 범위가 좁다
vendor prefix가 뭔지
- 각 브라우저에서 판독이 가능한 접두어를 붙여서 해당 브라우저에서 인식할 수 있게 하는 것




5. WEB UI - FE
----------------

### 1) 서비스 개발을 위한 디렉토리 구성

javascript 파일 구성
- 간단한 내용이면 한 페이지에 모두 표현하는것도 좋음
- 그렇지 않으면 의미에 맞게 구분

HTML 안에 자바스크립트 구성하기

- CSS는 head태그 상단에
- JS는 Body태그 닫히기전에 소스파일간 의존성을고려해 배치 먼저 불러질 코드를 위에 배치해야한다.


브라우저는 한줄씩 실행하기 때문에 html이 다 렌더링 되기 전에 자바스크립트 코드가 실행될 수 있다.
그러면 올바른 동작을 할 수 없다.

자바스크립트 코드가 많아지면 하나의 파일로 merge해서 배포한다. -> 무슨 방법일까?


### 2)DOM Conetent loaded 이벤트


- 웹사이트를 접속했을 때 컨텐츠르 서버로 받는다
- GET으로 www.eee.com 요청
- HTML을 내려받고 파싱
- CSS ? 받아오고
- 자바스크립트? 받아오고
- 렌더링하고
- 이미지받고
- 다 로딩이 되면 보인다

DOM 트리가 구성되기 전에 자바스크립트로 제어할 수 없다 따라서 제일 밑에 링크한다.
-> 그럼에도 불구하고 안될 수 있따.
웹 사이트에 접속하면 DOMConetentLoaded -> load

```javascrpit
document.addEventListner("DOMContentLoaded", function(){
    //DOM로드 완료 이벤트
    startSomething();
    initFoo();
    var el = document.querySelector("div");
})

window.addEventListener("load", function(){
    //load ... 쓸일이 많지는 않다.
})
```

DOMCententloaded안에 동작하는게 안전한 방법이다



### 3) Event delegation

addEventListener를 효율적으로 등록하는 방법

```javascript
for(var i = 0, len=lists.length; i < lists.length; i++){
    lists[i].addEventListener("click", function(evt){
        console.log(' ');
    });
}

firstElementChild 자주씀

ul.addEventListener('click', function(evt){
    console.log(evt.target.tagName, evt.currentTarget.tagName);
    //target을 통해 실제 클릭한 부분의 정보를 어등ㄹ 수 있다.
})
```

이벤트 버블링
    클릭한 지점이 하위엘리머트라고 하여도 그것을싸고 있는 상위 엘리먼트까지 올라가면서 이벤트리스너가 있는지 찾는 과정

### 4) HTML templating

웹화면에 데이터를 받아와서 표시한다거나. 웹 하면에 있는 내용을 삭제한다거나 등등 작업을 한다. HTML태그들이 다양하게 변경되어야 하는데 HTML과 데이터를 섞어서 화면에 변경을 주는 방법

HTML Templating 작업이란?
동일한 내용의 리스트들을 비슷한 태그를 이용해 표시하는 경우 여러 태그들을 하나로 묶어서 화면에 추가하는 작업
렌더링을 서버에서하느냐 클라이언트에서 할까는 주요 쟁점 : 적절한 방법을 선택히야 한다.

데이터만 필요할때 받아와서 HTML 테블릿과 결합하여 화면에 추가하는 작업

```javascript
<li>
	<h2>(title)</h2>
<li>

+

{
	title:"my title"
}
```

```javascript
var data={
	title : "my title",
    content : "data text",
    price : 2000
};

var html = "<li><h2>{title}</h2>{content}{price}</li>

//replace를 이용하는 방법
var resultHTML = html.replace("{title}", data.title)
				.replace("{content}", data.content)
				.replace("{price}", data.price)	//method channing
```

### 5) HTML Templating 실습

HTML 템플릿을 어떻게 보관하고 화면에 적용할 수 있는가...


```
var html = "<li><h2>{title}</h2>{content}{price}</li>
```
이런걸 자파스크립트 코드에서 가지고 있는건 좋지 않은 방법이다
- 서버에서 파일로 보관하고 Ajax로 요청해 받아온다.
- HTML 코드안에 숨겨둥다(?)

Templating
HTML 중 script 태그는 type이 javascript가 아니면 렌더링하지 않고 무시한다. 이걸 이용해 템플릿을 숨겨둘 수 있다.
```

//... html 코드들

<script id="template-list-item" type="text/template">	//가져올 템플릿
<li>
	<h2>{title}</h2>
   	<p>{content}</p>
    <div>{price}</div>
</li>
</script>
<script>
	//mock data
	var data=[ {
		title : "my title",
    	content : "data text",
    	price : 2000
	}
    ];

	var template = document.querySelector("teplate-list-item").innerHTML;
    var resultHTML = html.replace("{title}", data.title)
				.replace("{content}", data.content)
				.replace("{price}", data.price)	//method channing

    document.querySelector(".content").innerHTML = resultHTML;
</script>
```
이런 방식으로 가져올 수 있다.

템플릿을 조작하는 방법? replace 말고 뭐가 있을까
템플릿 보관
	간단한건 이렇게 해도 되지만 템플릿 자겅ㅂ을 많이 할 경우 서버단에 템플릿을 만들어 놓고 Ajax로 서버에서 데이터를 받아와서 쓰는방법이있고
    ES6에는 템플릿 리터럴을 쓰면 replace없이 간단히 할 수 있다(모든 브라우저 지원하는건 아님)`

6. Tab UI 실습
-----------------

### 1) Tab UI를 만들기 위한 HTML과 CSS 구조 전략

### 2_ Tab UI에 생명 불어넣기

컴포넌트 : Calandar, 검색창, 숫자버튼 등등
Tab도 이런 컴포넌트 중 하나






7. Spring Core - BE
-------------------

### 1) Spring이란?

Framework - 이미 기초적인 부분이 구현된 것을 이용하여 서비스 개발 : 복잡한 부분을

Spring
- 엔터프라이즈 급 어플리케이션을 구추갈 수 있는 가벼운 솔루션 : 모듈화가 잘 되어있다.
- 원하는 부분간 가져다 쓸 수 있도록 모듈화가 잘 되어있다.
- IoC 컨테이너 ???
- 선언적으로? 트랜잭션을 관리할 수 있따 ?? 코드 기반이 아니라
- 완전한 기능을 갖춘 MVC 프레임워크
- AOP 지원 : 잘 쓰면 좋은 기능이래 ㅣ쌉ㄹ 뭔
- 도메인 논리 코드와 쉽게 분리될 수 있는 구조

약 20개의 모듈로 구성되어 있따, 필요한 부분만 가ㅕㅈ다 쓸 수 있다.

데이터 엑세스 / 통합??

모듈들
spring-jdbc : 데이터베이스 프로그래밍을 간편히
spring-tx : 선언적 트랜잭션 관리 기능 제공

웹
spring-wen spring-webmvc spring-websocket spring-webmvc-portlet 모듈 등
- spring-web : 웹 지향 통합기능
webmvc REST웹 서비스 구현 을 포함


### 2) Spring DI/IoC

[참고링크](http://www.nextree.co.kr/p11247/)

#### 컨테이너란?
- 컨테이너는 인스턴스의 생명 주기를 관리한다.
- 생성된 인스턴스들에게 추가적인 기능을 제공한다.

WAS는 메모리를 올린 후 실행한다. 개발자가 작성한 서블릿을 실제 메모리에 올리고 실행하는 WAS가 가지고 있는  서블릿 컨테이너가 실행하는 것이다.

#### IOC란?
- Inversion of Control의 약어
- 개발자는 프로그램의 흐름을 제어하는 코드를 작성한다. 이 흐름의 제어를 개발자가 하는 것이 아니라 다른 프로그램이 하는 것을 IoC라고 한다.

동일한 인터페이스를 통해 사용자가 쓰는 입장에서 동일하게 구현해서 동일한 사용이 가능하도록 제공한다.
스프링이 가지고 있는 BeanFactory와 Application Context가 공장 같은 역할을 해준다.

#### DI란?
- 의존성 주입 받는 방법
- 공장이 만든 인스턴스를 내가 사용할 수 있도록 해주는거
DI는 클래스 사이의 의존관계를 빈(Bean) 설정 정보를 바탕을 ㅗ컨테이너가 자동으로 연결해 주는 것을 말한다.

DI가 적용 안된 예

``` java
class 엔진 {

}

class 자동차 {
     엔진 v = new 엔진();
}
```

DI가 적용된 예
- 엔진 tpye의 v 변수에 아직 인스턴스가 할당되지 앟ㄴ았따.
- 컨테이너가 v변수에 인스턴스를 할당해주게된다.


```java
@Component
class 엔진 {

}

@Component
class 자동차 {
     @Autowired
     엔진 v;
}
```

#### Spring에서 제공하는 IoC/DI 컨테이너
- BeanFactory : IoC/DI에 대한 기본기능을 가지고 있따.
- ApplicatoinConext : BeanFactory의 모든 기능 + 부가기능 : 일반적으로 추천된다.
- BeanPostProcessor는 컨테이너의 기본 로직을 오버라이딩 해서 인스턴스화와 의존성 처리 로직 등을 개발자가 원하는 대로 구현할 수 있게 해주는 것
- BeanFactorypostProcessor 설정 메타 데이터를 커스트마이징
- 공장에서 객체를 만드는데 사용자가 원하는 방법으로 만들어내고 사용하는 것을 도와준다.



### 3) xml파일을 이용한 설정

이클립스 -> file -> New -> maven project 생성
경로 설정 -> Artifact Id : maven-archetype-quickstart 선택
그룹id articact id 설정 -> finish

pom.xml 설정 : jdk 사용을 위한 plugin 추가

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>kr.or.connect</groupId>
  <artifactId>diexam01</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <packaging>jar</packaging>

  <name>diexam01</name>
  <url>http://maven.apache.org</url>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
  </properties>

  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>3.8.1</version>
      <scope>test</scope>
    </dependency>
  </dependencies>
  
-------------------------------------추가----------------------------------------------------
  <build>
     <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.6.1</version>
            <configuration>
                <source>1.8</source>
                <target>1.8</target>
            </configuration>
        </plugin>
    </plugins>
  </build>
----------------------------------------------------------------------------------------------

</project>
```

juint에 빨간줄 나오는거 없애기
problem 탭 -> warning 보면 업데이트하라고 나와있음
project 우클릭 -> maven -> update 하면됨

![프로젝트익스플로러](https://i.imgur.com/miGi2qf.png)

App.java와 AppTest.java를 볼 수 ㅣㅇㅆ다.

![testjava](https://i.imgur.com/JjHmNmE.png)
```
junit.framework.Test;
```
단위 테스트 할 수 있는 도구이다.

![test](https://i.imgur.com/hpwMMgV.png)
저걸 누르면 테스트 할 수 있다.

#### DI 주입하는거 테스트

```java
package com.nts.connect.diexam01;

public class UserBean {

}
```


공장이 자동으로 만들어주는 객체 : bean
일반적인 자바 클래스를 빈 클래스라고 한다.

##### Bean의 특징
- 기본 생성자를 가지고 있다.
- 필드는 private하게 선언되어있다.
- getter/setter를 가진다.
=> 생성을 내가 하는게 아니라 다른곳에서 하기 때문에 일정한 규칙을 가지고 있다.



userBean 클래스

```java

```

Application.xml
생성할 객체의 정보를 담고 있다.
이를 통해

```
com.nts.connetion.exam.UserBean userBean = new com.nts.connetion.exam.UserBean();
```

같이 생성을 하게 되는 것이다.

```xml



```

ApplicationConext를 통해 정보를 읽어와 객체를 생성하게 하도록 준비
```java
public static void main(String[] args){
	ApplicationConext ac = new ClassPathXmlApplicationConex("classpath:applicationContext.xml");
    //xml을 읽어오는 시점에서 저장된 bean의 객체를 생성시킨다. 싱글톤 기법으로 관리

    UserBean userBean = (UserBean)ac.getBean("userBean");	//getBean메소드는 id가 userBean인 애를 찾아 클래스를 찾아 생성한다.

    UserBean userBean2 = (UserBean)ac.getBean("userBean");
    if(userBean == userBean2){
    	//getBean을 통해 생성된 객체이기 때문에 동일한 객체를 가리키고 있다.
    }
}
```

객체를 대신 생성해 주고 싱클톤으로 관리해주는 기능 등을 IOC 제어 역전이라고 한다.

#### 의존성 주입

Engine

```java
package kr.or.connect.diexam01;

public class Engine {
	public Engine() {
		System.out.println("Engine 생성자");
	}

	public void exec() {
		System.out.println("엔진이 동작합니다.");
	}
}

```

Car

```java
package kr.or.connect.diexam01;

public class Car {
	Engine v8;

	public Car() {
		System.out.println("Car 생성자");
	}

	public void setEngine(Engine e) {
		this.v8 = e;
	}

	public void run() {
		System.out.println("엔진을 이용하여 달립니다.");
		v8.exec();
	}
}
```

Car 클래스가 동작하기 위해서는 다음과 같은 과정이 필요하다.
```
Engine e = new Engine();
Car c = new Car();
c.setEngine( e );
c.run();
```
Engine과 Car 객체를 생성하는 과정을 Spring 컨테이너에게 맡길 수 있다.


ApplicationContext.xml

```xml
<bean id="e" class="kr.or.connect.diexam01.Engine"></bean>
<bean id="car" class="kr.or.connect.diexam01.Car">
	<property name="engine" ref="e"></property>	//이 속성을 통해 의존성 주입
</bean>
```

```java
public static void main(String[] args){
	ApplicationConext ac = new ClassPathXmlApplicationConex("classpath:applicationContext.xml");

	Car car = (Car) ac.getBean("c");
    car.run();
}
```
- @Configuration 은 스프링 설정 클래스라는 의미를 가집니다.
- JavaConfig로 설정을 할 클래스 위에는 @Configuration가 붙어 있어야 합니다.
- ApplicationContext중에서 AnnotationConfigApplicationContext는 JavaConfig클래스를 읽어들여 IoC와 DI를 적용하게 됩니다.
- 이때 설정파일 중에 @Bean이 붙어 있는 메소드들을 AnnotationConfigApplicationContext는 자동으로 실행하여 그 결과로 리턴하는 객체들을 기본적으로 싱글턴으로 관리를 하게 됩니다.


```java
	public static void main(String[] args) {
		ApplicationContext ac = new AnnotationConfigApplicationContext(ApplicationConfig.class);

		Car car = (Car)ac.getBean("car");	//bean으로 지정된 메서드 이름
        //Car.class로 해도 됩
		car.run();
	}
```

### 4) JavaConfig를 이용한 설정

```java
@Configuration
public class ApplicationConfig {
	@Bean
	public Car car(Engine e) {
		Car c = new Car();
		c.setEngine(e);
		return c;
	}

	@Bean
	public Engine engine() {
		return new Engine();
	}
}
```
java의 annotation을 이용한다 : 컴파일시나 런타임시에 설정될 수 있따.

```@Configuration``` 설정임을 알리는 어노테이션
```@Bean```

```java
@Configuration
@ComponentScan("com.nts.connect.exam01")	//어노테이션이 붙어있는 이 패키지 안에 있는것을 모두 읽어와라
public class ApplicationConfig {
	@Bean
	public Car car(Engine e) {
		Car c = new Car();
		c.setEngine(e);
		return c;
	}

	@Bean
	public Engine engine() {
		return new Engine();
	}
}
```

##### @Autowired
적절한 어노테이션을 찾아 생성해라

```java
package kr.or.connect.diexam01;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class Car {
	@Autowired
	private Engine v8;

	public Car() {
		System.out.println("Car 생성자");
	}

	public void run() {
		System.out.println("엔진을 이용하여 달립니다.");
		v8.exec();
	}
}
```





8. Spring JDBC - BE
-------------

### 1) Spring JDBC 소개

- jdbc 프로그래밍을 보면 반복되는 개발요소가 있다.
- 스프링 프레임워크가 저수준 세부사항을 처리해준다.
- 개발자는 필요한 부분만 정의

개발자가 할거 : 연결 파라미터 정의, SQL문 지정, 파라미터 선언과 파라미터 값 제공, 각 이터레이션에 대한 작업 수행

#### Spring JDBC 패키지
- org.springframework.jdbc.core : JDBC 템플릿 클래스와 JDBC 템플릿의 다양한 콜백 인터페이스 포함, 추가 관련 클래스 포함
- org.springframework.jdbc.datasource : 데이터 소스 접근을 쉽게하는 유틸리티 클래스와  javaEE 컨테이너 외부에 수정되지 않고 운영되는 JDBC 코드, 테스트에서 사용할 수 있는 간단한 데이터소스 구현체 포함
- org.springframework.jdbc.object : RDBMS의 조회 갱신 저장 프로시저를 스레드 세이프하고 재상용 가능한 객체로 나타내는 클래스 포함
- org.springframework.jdbc.support : SQL Exception 변환 기능과 약간의 유틸리티 클래스

#### JDBC Template

- org.springframework.jdbc.core에서 가장 중요한 클래스입니다.
- 리소스 생성, 해지를 처리해서 연결을 닫는 것을 잊어 발생하는 문제 등을 피할 수 있도록 합니다.
- 스테이먼트(Statement)의 생성과 실행을 처리합니다.
- SQL 조회, 업데이트, 저장 프로시저 호출, ResultSet 반복호출 등을 실행합니다.
- JDBC 예외가 발생할 경우 org.springframework.dao패키지에 정의되어 있는 일반적인 예외로 변환시킵니다.


한건
```java
Actor actor = this.jdbcTemplate.queryForObject(

  "select first_name, last_name from t_actor where id = ?",

  new Object[]{1212L},

  new RowMapper<Actor>() {

    public Actor mapRow(ResultSet rs, int rowNum) throws SQLException {

      Actor actor = new Actor();

      actor.setFirstName(rs.getString("first_name"));

      actor.setLastName(rs.getString("last_name"));

      return actor;

    }

  });
```

여러건 조회
```java
List<Actor> actors = this.jdbcTemplate.query(

  "select first_name, last_name from t_actor",

  new RowMapper<Actor>() {

    public Actor mapRow(ResultSet rs, int rowNum) throws SQLException {

      Actor actor = new Actor();

      actor.setFirstName(rs.getString("first_name"));

      actor.setLastName(rs.getString("last_name"));

      return actor;

    }

  });

```

### 2) Spring JDBC 실습

#### DTO란?
- DataTransfer Object의 약자
- 계층간 데이터 교환을 위한 JavaBeans
- 계층이란 컨트롤러 뷰, 비지니스 계층, 퍼시스턴스 계층
- 로직을 가지고 있지 않은 순수한 데이터 객체

#### DAO란?
- Data Access Object
- 데이터를 조회하거나 조작하는 기능을 전담
- 데이터 베이스를 조작하는 기능을 전담하는 목적

#### ConnectionPool
- 프로그램이 DBMS에 접속하는 시간이 오래 걸린다. : 비용이 크다
- 빠른 접근을 위해 커넥션을 미리 많이 맺어준다.
- 커넥션이 필요하면 커넥션 풀에게 빌려 사용 후 반납한다.
- 커넥션 풀에 사용 가능한 커넥션이 없으면 대기

#### DataSource
- 커넥션 풀을 관리하는 목적으로 사요오디는 객체
- 커넥션을 얻어어고 반납하는 작업


1. 스프링 컨테이너 ApplicationConext config를 읽는다.
2. componentScanAnnotation이 DAO클래스를 찾도록 설정
3. 찾은 모든 DAO 클래스는 스프링 컨테이너가 관리
4. Application Context가 DBConfig 클래스 import
5. DBConfig 클래스는 데이터 소스와 트랜잭션 매니저 객체 생성
6. DAO는 필드로 NamedParameterJdbcTemplate와 SimpleJdbcInsert를 가진다. : DATA Sourece를 필요로한다. SQL 실행을 편리하게 하도록
7. 파라미터와 SQL을 신경써야한다.


#### 실습

1 Maven 프로젝트 생성 -> quickstart
![01](https://i.imgur.com/S8FjH06.png)

2 id 설정하고 finish

3 porm.xml
database, mysql, data source 추가
해주고 maven->update project 실행
```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>com.nts.connect</groupId>
  <artifactId>daoexam</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <packaging>jar</packaging>

  <name>daoexam</name>
  <url>http://maven.apache.org</url>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <!-- 버전 관리를 위해 상수처럼 쓸 수 있도록-->
    <!-- ${spring.version} 이렇게 사용 가능-->
    <spring.version>4.3.5.RELEASE</spring.version>
  </properties>

  <dependencies>
  <!-- Spring -->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-context</artifactId>
			<version>${spring.version}</version>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-jdbc</artifactId>
			<version>${spring.version}</version>
		</dependency>

		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-tx</artifactId>
			<version>${spring.version}</version>
		</dependency>

		<!-- basic data source -->
		<dependency>
			<groupId>org.apache.commons</groupId>
			<artifactId>commons-dbcp2</artifactId>
			<version>2.1.1</version>
		</dependency>

		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<version>5.1.45</version>
		</dependency>
		
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>3.8.1</version>
      <scope>test</scope>
    </dependency>
  </dependencies>
  <!-- JRE 1.8로 -->
  <build>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<version>3.6.1</version>
				<configuration>
					<source>1.8</source>
					<target>1.8</target>
				</configuration>
			</plugin>
		</plugins>
	</build>
</project>
```

4 ApplicationConfig 클래스 생성
```java
package com.nts.connect.daoexam.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

@Configuration //config라고 명시 실행되면서 여기 설정에 대한 정보를 읽을 수 있다.
@ComponentScan(basePackages = {"com.nts.connect.daoexam.dao"}) //Bean등록 방법으로 Annotation을 했으니 이걸 추가해야한다. 패키지를 여러개 나열할 수있다.
@Import({DBConfig.class}) //설정 파일을 여러개로 나누어서 사용할 수 있다.
public class ApplicationConfig {

}
```


5 테스트코드 실행
```java
package com.nts.connect.daoexam.main;

import java.sql.Connection;

import javax.sql.DataSource;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

import com.nts.connect.daoexam.config.ApplicationConfig;

public class DataSourceTest {

	public static void main(String[] args) {
		ApplicationContext ac = new AnnotationConfigApplicationContext(ApplicationConfig.class);
		DataSource ds = ac.getBean(DataSource.class);

		try (Connection conn = ds.getConnection()) {
			if (conn != null) {
				System.out.println("접속 성공^^");
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

}
```
---

###### 테스트 오류
maven dependencies가 충돌이 일어나서 그런듯
ApplicationContext를 import할 수 없다.

![03](https://i.imgur.com/cBvuP2b.png)

패키지에 빨간줄 뜨면서 안됨
```
The type org.springframework.context.support.GenericApplicationContext cannot be resolved. It is indirectly referenced from required .class files
```

이클립스 끄고
```
C:\Users\USER\.m2\repository\org
```
에서 spingframework 지우고 다시 이클립스 들어가서 maven update



#### query select 실습

DTO 생성
```java
package com.nts.connect.daoexam.dto;

public class Role {
	private int roleId;
	private String description;

	public int getRoleId() {
		return roleId;
	}

	public void setRoleId(int roleId) {
		this.roleId = roleId;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}
    @Override
	public String toString() {
		return "Role [roleId=" + roleId + ", description=" + description + "]";
	}
}
```

RoleDaoSqls

```java
package com.nts.connect.daoexam.dao;

public class RoleDaoSqls {
	public static final String SELECT_ALL = "SELECT role_id, description FROM role ORDER BY role_id";
}

```

```java
package com.nts.connect.daoexam.dao;

import static com.nts.connect.daoexam.dao.RoleDaoSqls.SELECT_ALL;

import java.util.Collections;
import java.util.List;

import javax.sql.DataSource;

import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.simple.SimpleJdbcInsert;
import org.springframework.stereotype.Repository;

import com.nts.connect.daoexam.dto.Role;

@Repository
public class RoleDao {
	private NamedParameterJdbcTemplate jdbc;
	private SimpleJdbcInsert insertAction;
	private RowMapper<Role> rowMapper = BeanPropertyRowMapper.newInstance(Role.class);

	public RoleDao(DataSource dataSource) {
		this.jdbc = new NamedParameterJdbcTemplate(dataSource);
		this.insertAction = new SimpleJdbcInsert(dataSource)
			.withTableName("role");
	}

	public List<Role> selectAll() {
		return jdbc.query(SELECT_ALL, Collections.emptyMap(), rowMapper);
	}

}
```

Select All Test
```java
package com.nts.connect.daoexam.main;

import java.util.List;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

import com.nts.connect.daoexam.config.ApplicationConfig;
import com.nts.connect.daoexam.dao.RoleDao;
import com.nts.connect.daoexam.dto.Role;

public class SelectAllTest {

	public static void main(String[] args) {
		ApplicationContext ac = new AnnotationConfigApplicationContext(ApplicationConfig.class);

		RoleDao roleDao = ac.getBean(RoleDao.class);

		List<Role> list = roleDao.selectAll();

		for (Role element : list) {
			System.out.println(element);
		}
	}

}
```

###### 근데 role_id가 roleID로 자동으로 변환되는데 DB필드에 role_id와 roleId가 같이있으면 어떻게 될까?

```
+---------+--------+-------------+
| role_id | roleId | description |
+---------+--------+-------------+
|   10001 | 200001 | hello       |
|   10002 | 200002 | hello11     |
|   10003 | 200003 | world       |
+---------+--------+-------------+
```

```
RoleDto [roleId=0, role_id=10001, description=hello]
RoleDto [roleId=0, role_id=10002, description=hello11]
RoleDto [roleId=0, role_id=10003, description=world]
```
roleId는 아예 처리하지 않는 것을 볼 수 있다.


##### query insert 실습


dao에 insert 메소드 정의
```java
package com.nts.connect.daoexam.dao;

import static com.nts.connect.daoexam.dao.RoleDaoSqls.SELECT_ALL;

import java.util.Collections;
import java.util.List;

import javax.sql.DataSource;

import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.jdbc.core.simple.SimpleJdbcInsert;
import org.springframework.stereotype.Repository;

import com.nts.connect.daoexam.dto.RoleDto;

@Repository
public class RoleDao {
	private NamedParameterJdbcTemplate jdbc;
	private SimpleJdbcInsert insertAction;
	private RowMapper<RoleDto> rowMapper = BeanPropertyRowMapper.newInstance(RoleDto.class);

	public RoleDao(DataSource dataSource) {
		this.jdbc = new NamedParameterJdbcTemplate(dataSource);
		this.insertAction = new SimpleJdbcInsert(dataSource)
			.withTableName("role");
	}

	public List<RoleDto> selectAll() {
		return jdbc.query(SELECT_ALL, Collections.emptyMap(), rowMapper);
	}

	public int insert(RoleDto dto) {
		SqlParameterSource params = new BeanPropertySqlParameterSource(dto);
		return insertAction.execute(params);
	}
}
```

테스트 코드
```java
package com.nts.connect.daoexam.main;

import java.util.List;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

import com.nts.connect.daoexam.config.ApplicationConfig;
import com.nts.connect.daoexam.dao.RoleDao;
import com.nts.connect.daoexam.dto.RoleDto;

public class TestMain {

	public static void main(String[] args) {
		ApplicationContext ac = new AnnotationConfigApplicationContext(ApplicationConfig.class);

		RoleDao roleDao = ac.getBean(RoleDao.class);

		List<RoleDto> list = roleDao.selectAll();

		for (RoleDto element : list) {
			System.out.println(element);
		}

		RoleDto role = new RoleDto();
		role.setRoleId(100);
		role.setDescription("insert test");

		int cnt = roleDao.insert(role);
		System.out.println("cnt : " + cnt);

		list = roleDao.selectAll();

		for (RoleDto element : list) {
			System.out.println(element);
		}
	}

}

```

##### Update 싫습


dao에 update 메소드 추가

```java
package com.nts.connect.daoexam.dao;

import static com.nts.connect.daoexam.dao.RoleDaoSqls.SELECT_ALL;
import static com.nts.connect.daoexam.dao.RoleDaoSqls.UPDATE;

import java.util.Collections;
import java.util.List;

import javax.sql.DataSource;

import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.jdbc.core.simple.SimpleJdbcInsert;
import org.springframework.stereotype.Repository;

import com.nts.connect.daoexam.dto.RoleDto;

@Repository
public class RoleDao {
	private NamedParameterJdbcTemplate jdbc;
	private SimpleJdbcInsert insertAction;
	private RowMapper<RoleDto> rowMapper = BeanPropertyRowMapper.newInstance(RoleDto.class);

	public RoleDao(DataSource dataSource) {
		this.jdbc = new NamedParameterJdbcTemplate(dataSource);
		this.insertAction = new SimpleJdbcInsert(dataSource)
			.withTableName("role");
	}

	public List<RoleDto> selectAll() {
		return jdbc.query(SELECT_ALL, Collections.emptyMap(), rowMapper);
	}

	public int insert(RoleDto dto) {
		SqlParameterSource params = new BeanPropertySqlParameterSource(dto);
		return insertAction.execute(params);
	}

	public int update(RoleDto dto) {
		SqlParameterSource params = new BeanPropertySqlParameterSource(dto);
		return jdbc.update(UPDATE, params);
	}
}
```


##### 검색/삭제

sqls
```java
package com.nts.connect.daoexam.dao;

public class RoleDaoSqls {
	public static final String SELECT_ALL = "SELECT role_id, description FROM role ORDER BY role_id";
	public static final String UPDATE = "UPDATE role SET description = :description WHERE ROLE_ID = :roleId";
	public static final String SELECT_BY_ROLE_ID = "SELECT role_id, description FROM role where role_id = :roleId";
	public static final String DELETE_BY_ROLE_ID = "DELETE FROM role WHERE role_id = :roleId";
}
```


9. Spring MVC - BE
-------------

### 1) Spring MVC란?

#### MVC?
- Model-View-Controller
- Model : 뷰가 렌더링 하는데 필요한 데이터
- View : 웹 어플리케이션에서 뷰는 실제로 보이는 부분, 모델을 사용해 렌더링
- Controller : 사용자의 액션에 응답하는 컴포넌트, 모델을 업데이트하고 다른 액션을 수행

#### MVC Model 1 아키텍쳐
![model1](https://i.imgur.com/itZG0t4.png)

브라우저 요청을 JSP가 처리 -> 자바빈을 통해처리
JSP 자체에 자바코드와 HTML태그 혼재 : 유지보수 어려움

#### MVC Model2 아키텍쳐
![model2](https://i.imgur.com/uUk5dqM.png)

서블릿이 요청과 데이터를 처리하는 컨트롤러 역할, JSP가 뷰의 역할 -> 로직과 뷰를 분리

##### MVC Model2 발전형태
![model22](https://i.imgur.com/oslWtfV.png)

클라이언트가 봰는 모든 요청은 프론트 컨트롤러라는 서블릿이 처리, 요청만 받고 처리하지 않고 컨트롤러 클래스(핸들러 클래스)에 위임 : 관련된 URL을 하나의 클래스에서 모두 처리할 수 있게 됬다.
컨트롤러가 처리한 모델(빈)을 프론트 컨트롤러에 보내고 뷰에서 처리하게하고 응답을 보내게 된다.

###### Spring MVC가 Model2를 적용한것이다.
![spring](https://i.imgur.com/s9wMyYd.png)

### 2)Spring MVC 구성요소

#### 학습 목표
1. DispacherServlet이 어떤 순서로 동작하는지 이해한다.
2. DispacherServlet에서 사용되는 컴포넌트(객체)들이 어떤 것들이 있는지 안다.

#### 핵심 개념
- DispacherServlet
- HandlerMapping
- HandlerAdpater
- ViewResolver

#### Spring MVC 기본 동작 흐름

![](https://i.imgur.com/N7e6TKc.png)


1. 클라이언트가 요청을 보내ㅕㅁㄴ Dispatch Servlet이 받아 요청을 처리해줄 컨트롤러가 무엇인지 Handler Mapping에서 정보를 알아낸다.
2. Handler Mapping이 처리할 정보를 xml에서 넣는다.
3. DispatcherServlet이 Handler Adapter를 통해 컨트롤에게 전달
4. Controler가 리턴한 view name을 가ㅣㅈ고 view resolver를 통해 출력한다.
5. View로 응답을 보낸다.


#### 요청을 위해 사용되는 컴포넌트
DispatcherServlet이 어떻게 동작하는지 알아야 한다.


#### DispatcherServlet
- 프론트 컨트롤러
- 클라이언트의 모든 요청을 받은 후 이를 처리할 핸들러에게 넘기고 핸들러가 처리한 결과를 받아 사용자에게 응답 결과를 보여준다.
- DispatcherServlet은 여러 컴포넌트를 이용해 작업을 처리한다.
- 이론상 여러개 쓸수 있지만 일반적으로 한개만 쓴다.

#### Dispatcher Servlet 내부 동작흐름

![0002](https://i.imgur.com/yBJTFL2.png)

- 요청이 들어오면 요청 선처리 작업 : 그냥 처리하는게 아니라 작업을 거치낟
- HandlerExecutionChain 결정
- HanderExecutionChain 실행
- 예외?
- 뷰렌더링
- 요청처리
- 요청처리 종료

##### 요청 선처리 작업
![0001](https://i.imgur.com/jSjqm3P.png)

- Locale 결정 : 지역화? 브라우저 언어 세팅에 따라 결정
- RequestContextHolder에 요청 저장 : 스레드 로컬 객체로 요청을 받아 처리할 때까지 Spring이 관리하는 객체안에서 사용할 수 있도록 저장 - 아주 권장하는 방법은 아니다. 스프링에서  HttpServletRequest 제공하는걸 쓰자
- FlashMap : 리다이렉트로 전달하는 값을 유지하도록
- 멀티파트요청? : 파일 정보를 읽을때는 특수한 요청을 처리해야한다.
- 핸들러 결정과 실행한다.

사용되는 컴포넌트
- org.springframework.web.servlet.LocaleResolver
 - 지역 정보를 결정해주는 전략 오브젝트이다.
 - 디폴트인 AcceptHeaderLocalResolver는 HTTP 헤더의 정보를 보고 지역정보를 설정해준다.
org.springframework.web.servlet.FlashMapManager
 - FlashMap객체를 조회(retrieve) & 저장을 위한 인터페이스
 - RedirectAttributes의 addFlashAttribute메소드를 이용해서 저장한다.
 - 리다이렉트 후 조회를 하면 바로 정보는 삭제된다.
- org.springframework.web.context.request.RequestContextHolder
 - 일반 빈에서 HttpServletRequest, HttpServletResponse, HttpSession 등을 사용할 수 있도록 한다.
 - 해당 객체를 일반 빈에서 사용하게 되면, Web에 종속적이 될 수 있다.
- org.springframework.web.multipart.MultipartResolver
 - 멀티파트 파일 업로드를 처리하는 전략

##### 요청 전달

![](https://i.imgur.com/YBXvJwj.png)


- HandlerMapping으로 Chain결정
- Chain 발견?
 - 못하면 Http 404전달
- Adapter 발견?
 - 못하면 ServletExecption 발생
- 요청 처리

요청전달시 사용된 컴포넌트
- HandlerMapping
 - 어떤 핸들러가 요청을 처리할지에 대한 정보를 알고있따.
 - 디폴트로 BeanNameHandlerMapping과 DefaultAnnotationHandlerMapping이 설정되어있다.
- HandlerExecutionChain
 - 실제로 호출된 핸들러에 대한 참도를 가지고 있다.
 - 무엇이 실행되어야 할지 알고 있는 객체 : 핸들러 실행전과 실행후에 수행될 HandlerInterceptor도 참조하고 있음
- HandlerAdapter
 - 실제 핸들러를 실행하는 역할
 - 선택된 핸들러를 실행하는 방법과 응답을 ModelAndView로 변화하는 방법에 대해 알고 있다.
 - HttpRequestHandlerAdapter, SimpleControllerHandlerAdapter, AnnotationMethodHanderAdapter 3가지가 디폴트로 설정된 핸들러어댑터
 - @RequestMapping @Controller를 통해 정의된 컨트롤러의 경우DefaultAnnotationHandlerMapping에 의해 핸들러가 결정되고, 그에 대응하는 AnnotationmethodHandlerAdapter에 의해 호출이 일어난다.

##### 요청 처리

Chain이 결정되면 사용 가능한 인터셉터가 있나 찾는다 : 인터셉더는 챕터5쯤에 다시
인터셉터는 일종의 필터

![](https://i.imgur.com/YRHKltN.png)

- 사용가능한 ㅣㅇㄴ터셉터가 존재? : 요청처리
- 핸들러실행

요청시 사용되는 컴포넌트
- ModelAndView
 - Controller의 처리 결과를 보여줄 view와 view에서 사용할 값을 전달하는 클래스 : 서블릿에서 쓴 request에 값넣어서 쓴거 같은거
- RequestToViewNameTranslator
 - 컨트롤러에서 뷰 ㅣㅇ름이나 뷰 오브젝트를 제공해주지 않았을 경우 URL과 같은 요청정보를 참고해 자동으로 뷰 이름을 생성해 주는 전략 오브젝트
 - 디폴트는 DefaultRequestToViewNameTranslator


##### 예외처리

![](https://i.imgur.com/CzAX5E6.png)

사용된 컴포넌트
- HandlerExceptionResolver
 - 기본적으로 DispatcherServlet이 DefaultHandlerExceptoinResolver를 등록
 - 예뢰가 전져졌을 때 어떤 핸들러를 실행할 것인지에 대한 정보를 제공


##### 뷰 렌더링

![](https://i.imgur.com/85Pi6aN.png)

- 구현체를 찾을 수 업승면 ServletException 던짐

뷰 렌더링 과정시 사용된 컴포넌트
- ViewResolver
 - 컨트롤러가 리턴한 뷰 이름을 참고해서 적절한 오브젝트를 찾아주는 로직을 가진 전략 오브젝트
 - 뷰의 종류에 따라 적절한 ViewResolver를 추가로 설정할 수 있다.

##### 요청 처리 종료

![](https://i.imgur.com/NC0Ei3W.png)


### 3)Spring MVC를 이용한 웹 페이지 작성 실습

#### 학습 목표
- Spring MVC를 이용해 프로젝트를 구성할 수 있고, 개발자가 작성해야 할 파일이 무엇인지 이해한다.
- Spring MVC를 이용해 웹 어플리케이션을 작성할 수 있다.

#### 핵심 개념
- DispacherServlet
- WebApplicationInitializer
- @RequestMapping = @GetMapping = @PostMapping

#### Controller작성 실습 1/3

- 웹 브라우저에서 http://localhost:8080/mvcexam/plusform 이라고 요청을 보 내면 서버는 웹 브라우저에게 2개의 값을 입력받을 수 있는 입력 창과 버튼이 있는 화면을 출력한다.
- 웹 브라우저에 2개의 값을 입력하고 버튼을 클릭하면 http://localhost:8080/mvcexam/plus URL로 2개의 입력값이 POST방식으로 서버에게 전달한다. 서버는 2개의 값을 더한 후, 그 결과 값을 JSP에게 request scope으로 전달하여 출력한다.

maven webapp 생성 후 porm.xml 수정
```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<groupId>com.nts.connect</groupId>
	<artifactId>mvcexam</artifactId>
	<packaging>war</packaging>
	<version>0.0.1-SNAPSHOT</version>
	<name>mvcexam Maven Webapp</name>
	<url>http://maven.apache.org</url>

	<!-- Properties Setting -->
	<properties>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		<spring.version>4.3.5.RELEASE</spring.version>
	</properties>

	<dependencies>
		<!-- Spring -->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-context</artifactId>
			<version>${spring.version}</version>
		</dependency>
		<!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-webmvc</artifactId>
			<version>${spring.version}</version>
		</dependency>

		<!--  Servlet and JSTL -->
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>javax.servlet-api</artifactId>
			<version>3.1.0</version>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>jstl</artifactId>
			<version>1.2</version>
		</dependency>

		<!--  JUNIT -->
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>4.12</version>
			<scope>test</scope>
		</dependency>
	</dependencies>
	<build>
		<finalName>mvcexam</finalName>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<version>3.6.1</version>
				<configuration>
					<source>1.8</source>
					<target>1.8</target>
				</configuration>
			</plugin>
		</plugins>
	</build>
</project>


```

네비게이터 .setting에서 Servlet 3.1로
![](https://i.imgur.com/LUVpqfS.png)


#### DispatcherServlte을 FrontController로 설정하기

- frontcontroller 역할을 하도록 설정을 해줘야한다.
- web.xml 파일에 설정	<- 가장많이
- ServletContainerInitializer 사용
 - 서블릿 3.0 스펙 이상에서 web.xml을 대신해서 사용할 수 있다.
- WebApplicationInitializer 인터페이스를 구현해 사용 <- 가장많이


##### web.xml 파일에서 설정
- xml spring 설정을 읽어들이도록 DispatcherServlet 설정


url pattern을 /로 하면 모든 요청을 받게 된다.

##### WebApplicationInitializer를 구현해서 설정
- 단점 : 초기화 할 때 오래 걸릴 수 있따. : SpringMVC가 WebApplicationInitializer 인터페이스를 구현한 구현체를 찾고 해당 객채으 ㅣonStartup메소드를 이용해 초기화를 하기 때문에

이렇게도 하는구나 소개만 합니다.


##### Spring MVC 설정

![](https://i.imgur.com/xrvBqpz.png)

@Configuration : 자바 Config파일임을 알림

@EnableWebMvc
- 웹에 필요한 빈을 자동으로 설정해준다.
- xml로 설정의 <mvc:annotation-driven/>와 동일하다 <- 잘 안쓰는 방법
- 기볼 설정 이외의 설정이 필요하면 WebMvcConfigurerAdapter를 상속받도록 Javaconfig class를 작성한 후, 필요한 메소드를 오버라이딩하도록 한다.

![](https://i.imgur.com/gLB2fYf.png)

WWebMvcConfigurationSuppert를 상속받아 하고있다.

@ComponentScan
- 어떤 애가 controller, Service, Repository, Component 애노테이션이 붙은 클래스를 찾아 스프링 컨테이너가 관리하게 된다.
- ComponentScan애노테이션을 이용하면 Controller, Service, Repository, Component애노테이션이 붙은 클래스를 찾아 스프링 컨테이너가 관리하게 된다.
- DefaultAnnotationHandlerMapping과 RequestMappingHandlerMapping구현체는 다른 핸드러 매핑보다 훨씬 더 정교한 작업을 수행한다. 이 두 개의 구현체는 애노테이션을 사용해 매핑 관계를 찾는 매우 강력한 기능을 가지고 있다. 이들 구현체는 스프링 컨테이너 즉 애플리케이션 컨텍스트에 있는 요청 처리 빈에서 RequestMapping애노테이션을 클래스나 메소드에서 찾아 HandlerMapping객체를 생성하게 된다.
 - HandlerMapping은 서버로 들어온 요청을 어느 핸들러로 전달할지 결정하는 역할을 수행한다.
- DefaultAnnotationHandlerMapping은 DispatcherServlet이 기본으로 등록하는 기본 핸들러 맵핑 객체이고, RequestMappingHandlerMapping은 더 강력하고 유연하지만 사용하려면 명시적으로 설정해야 한다.


##### WwebMvcConfigurerAdapter
@EnableWebMvc를 이용하면 기본적인 설정이 모두 자동으로 되지만, 기본 설정 이외이ㅡ 설정이 필요할 경우 해당 클래스를 상속 받은 후, 메소드를 오버라이딩 하여 구현한다.

##### Controller(Handler) 클래스 작성하기

- @Controller 애노테이션을 클래스 위에 붙인다.
- 매핑을 위해 @RequestMapping 애노테이션을 클래스나 메소드에서 사용한다. : 실제로 처리하는 컨트롤러가 뭔지 찾기 위해

##### @RequestMapping
- http 요청고 ㅏ이를 다루기 위한 Controller의 메소드를 연결하는 어노테이션
- 방법
 - @RequestMapping("/users", method=RequestMethod.POST)
 - From Spring 4.3ver
  - GetMapping
  - PostMapping
  - PutMapping
  - DeleteMapping
  - PatchMapping
- Http 특정 해더와 연결하는 방법
 - @RequestMapping(method = RequestMethod.GET, headers = "content-type=application/json")
- Http Parameter 와 연결하는 방법
 - @RequestMapping(method = RequestMethod.GET, params = "type=raw")
- Content-Type Header 와 연결하는 방법
 - @RequestMapping(method = RequestMethod.GET, consumes = "application/json")
- Accept Header 와 연결하는 방법
 - @RequestMapping(method = RequestMethod.GET, produces = "application/json")


WebMvcContextConfiguration 클래스 생성

```java
package com.nts.connect.mvcexam.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;
import org.springframework.web.servlet.view.InternalResourceViewResolver;

@Configuration
@EnableWebMvc
@ComponentScan(basePackages = {"com.nts.connect.mvcexam.controller"})
public class WebMvcContextConfiguration extends WebMvcConfigurerAdapter {

	//css나 js 등 다른 요청들이 왔을때도 /로 매핑되어버리기 때문에 그 부분을 처리
	@Override
	public void addResourceHandlers(ResourceHandlerRegistry registry) {
		registry.addResourceHandler("/assets/**").addResourceLocations("classpath:/META-INF/resources/webjars/")
			.setCachePeriod(31556926);
		registry.addResourceHandler("/css/**").addResourceLocations("/css/").setCachePeriod(31556926);
		registry.addResourceHandler("/img/**").addResourceLocations("/img/").setCachePeriod(31556926);
		registry.addResourceHandler("/js/**").addResourceLocations("/js/").setCachePeriod(31556926);
	}

	// default servlet handler를 사용하게 합니다.
	// 매핑 정보가 없는 요청은 여기서 처리하도록 한다.
	@Override
	public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
		configurer.enable();
	}

	//특정 url에 대한 처리를 컨트로러 클래스를 작성하지 않고 매핑할 수 있도록
	@Override
	public void addViewControllers(final ViewControllerRegistry registry) {
		System.out.println("addViewControllers가 호출됩니다. ");
		registry.addViewController("/").setViewName("main"); // /요청을 main 뷰로
	}

	//뷰 정보를 지정
	@Bean
	public InternalResourceViewResolver getInternalResourceViewResolver() {
		InternalResourceViewResolver resolver = new InternalResourceViewResolver();
		resolver.setPrefix("/WEB-INF/views/");
		resolver.setSuffix(".jsp");
		return resolver;
	}
}
```

DispatcherServlet을 fontController로 설정해야한다.
web.xml에 내용 추가해야함

```xml
<?xml version="1.0" encoding="UTF-8"?>

<web-app>
  <display-name>Archetype Created Web Application</display-name>
  <servlet>
    <servlet-name>mvc</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
      <param-name>contextClass</param-name>
      <param-value>org.springframework.web.context.support.AnnotationConfigWebApplicationContext</param-value>
    </init-param>
    <init-param>
      <param-name>contextConfigLocation</param-name>
      <param-value>com.nts.connect.mvcexam.config.WebMvcContextConfiguration</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
  </servlet>
  <servlet-mapping>
    <servlet-name>mvc</servlet-name>
    <url-pattern>/</url-pattern>
  </servlet-mapping>
</web-app>
```

##### Controller 작성 실습

jsp 2개 작성

plusform.jsp

```xml
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Plus Form</title>
</head>
<body>
<form method="post" action="plus">
value1 : <input type="text" name="value1"><br>
value2 : <input type="text" name="value2"><br>
<input type="submit" value="확인">
</form>
</body>
</html>
```

plusResult.jsp

```xml
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Plus Result</title>
</head>
<body>
${value1} 더하기 ${value2} (은/는) ${result} 입니다.
</body>
</html>
```


Contoller 작성
```java
package com.nts.connect.mvcexam.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.ModelMap;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;

@Controller //controller임을 명시한다.
public class PlustController {
	@GetMapping(path = "plusForm")
	//ModelAndView로해도 되고 여기는 간단하니 String으로
	public String plusform() {
		//요청이 들어왔을때 저 view를 보여줘여요
		//view만 찾아서 넘겨주면 됨
		return "plusForm"; //이름만 넘겨준다. 설정에서 resolver가 .jsp붙이고 WEB-INF/view/를 붙인다.
	}

	@PostMapping(path = "plus")
	//Spring MVC는 Controller 메소드 인수로 다양한 인수 타입을 제공하기 때문에 잘 보고 할 수 있다.
	public String plus(@RequestParam(name = "value1", required = true) int value1,
		@RequestParam(name = "value2", required = true) int value2, ModelMap modelMap) {
		int result = value1 + value2;

		//스프링이 알아서 request scope에 지정한다.
		modelMap.addAttribute("value1", value1);
		modelMap.addAttribute("value2", value2);
		modelMap.addAttribute("result", result);
		return "plusResult";
	}
}
```

###### @RequestParam
- Mapping된 메소드의 Argument에 붙일 수 있는 어노테이션
- @RequestParam의 name에는 http parameter의 name과 멥핑
- @RequestParam의 required는 필수인지 아닌지 판단

###### @PathVariable
- @RequestMapping의 path에 변수명을 입력받기 위한 place holder가 필요함
- place holder의 이름과 PathVariable의 name 값과 같으면 mapping 됨
- required 속성은 default true 임

###### @RequestHeader
- 요청 정보의 헤더 정보를 읽어들 일 때 사용
- @RequestHeader(name="헤더명") String 변수명

###### Spring MVC가 지원하는 메소드 리턴 값
- org.springframework.web.servlet.ModelAndView
- org.springframework.ui.Model
- java.util.Map
- org.springframework.ui.ModelMap
- org.springframework.web.servlet.View
- java.lang.String
- java.lang.Void
- org.springframework.http.HttpEntity<?>
- org.springframework.http.ResponseEntity<?>
- 기타 리턴 타입 ...


plusform ...

![](https://i.imgur.com/H7Eynsm.png)


plus ...

![](https://i.imgur.com/Xcc7Rii.png)



#### Controller작성 실습 2/3
- http://localhost:8080/mvcexam/userform 으로 요청을 보내면 이름, email, 나이를 물어보는 폼이 보여진다.
- 폼에서 값을 입력하고 확인을 누르면 post방식으로 http://localhost:8080/mvcexam/regist 에 정보를 전달하게 된다.
- regist에서는 입력받은 결과를 콘솔 화면에 출력한다.


##### jsp 만들기

userform.jsp
```html
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html lang="ko">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>
<form method="post" action="regist">
name : <input type="text" name="name"><br>
email : <input type="text" name="email"><br>
age : <input type="text" name="age"><br>
<input type="submit" value="확인">
</body>
</html>
```
UserController.java
```java
package com.nts.connect.mvcexam.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

import com.nts.connect.mvcexam.dto.UserDto;

@Controller
public class UserController {
	@RequestMapping(path = "/userform", method = RequestMethod.GET)
	public String userform() {
		return "userform";
	}

	@RequestMapping(path = "/regist", method = RequestMethod.POST)
	public String regist(@ModelAttribute UserDto user) {
		System.out.println("Infor : " + user);
		return "regist";
	}
}
```

UserDto

```java
package com.nts.connect.mvcexam.dto;

public class UserDto {
	private String name;
	private String email;
	private int age;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getEmail() {
		return email;
	}

	public void setEmail(String email) {
		this.email = email;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	@Override
	public String toString() {
		return "UserDto [name=" + name + ", email=" + email + ", age=" + age + "]";
	}

}

```

regist.jsp

```html
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html lang="ko">
<head>
<meta http-equiv="Content-Type" content="text/html; charsetUTF-8">
<title>Regist</title>
</head>
<body>
성공
</body>
</html>
```


##### 한글이 깨질 경우
다음을 ```web.xml```에 추가한다.
```xml
  <filter>
    <filter-name>encodingFilter</filter-name>
    <filter-class>
      org.springframework.web.filter.CharacterEncodingFilter
    </filter-class>
    <init-param>
          <param-name>encoding</param-name>
          <param-value>UTF-8</param-value>
    </init-param>
  </filter>
  <filter-mapping>
    <filter-name>encodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
  </filter-mapping>
```

#### Controller작성 실습 3/3

- http://localhost:8080/mvcexam/goods/{id} 으로 요청을 보낸다.
- 서버는 id를 콘솔에 출력하고, 사용자의 브라우저 정보를 콘솔에 출력한다.
- 서버는 HttpServletRequest를 이용해서 사용자가 요청한 PATH정보를 콘솔에 출력한다.


goodsById.jsp
```html
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html lang="ko">
<head>
<meta http-equiv="Content-Type" content="text/html; charsetUTF-8">
<title>Goods By Id</title>
</head>
<body>
id : ${id } <br>
user_agent : ${userAgent }<br>
path : ${path }<br>
</body>
</html>
```

GoodsController
```java
package com.nts.connect.mvcexam.controller;

import javax.servlet.http.HttpServletRequest;

import org.springframework.stereotype.Controller;
import org.springframework.ui.ModelMap;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestHeader;

@Controller
public class GoodsController {
	@GetMapping("/goods/{id}")
	public String getGoodsById(@PathVariable(name = "id") int id,
		@RequestHeader(value = "User-Agent", defaultValue = "myBrowser") String userAgent,
		HttpServletRequest request,
		ModelMap model) {

		String path = request.getServletPath();

		System.out.println("id : " + id);
		System.out.println("user_agent : " + userAgent);
		System.out.println("path : " + path);

		model.addAttribute("id", id);
		model.addAttribute("userAgent", userAgent);
		model.addAttribute("path", path);
		return "goodsById";
	}
}

```




10. 레이어드 아키텍처(Layered Architecture)
-------------------------------------------------------------------

### 1)레이어드 아키텍쳐(Layered Architecture)란?

#### 웹페이지에 Controller에서 중복된 부분을 처리하려먼?
- 별도의 객체로 분리하낟.
- 별도의 메소드로 분리
- 목록을 보기와 게시판에서 공통으로 회원 정보르 읽어와야 한다면 이 읽어오는 코드는 어디에 있어야할까? => 별도의 객체로 만들어 놓고 사용한다.

#### 컨트롤러와 서비스
- 비지니스 메소드를 별도의 Service객체에 구현하도록 하고 컨트롤러에는 Service 객체를 사용하도록 한다.

#### Service 객체란?
- 비지니스 로직을 수행하는 메소드를 가지고 있는 객체
- 하나의 비지니스 로직은 하나의 트랜잭션으로 실행

#### 트랜잭션이란?
- 논리적인 하나의 작업
- 특징

##### 원자성
동작은 전체가 성공하거나 실패하거나로 나뉜다
출금이라는 동작 중 중간에 오류가 발생하여 실패할 경우 동작 전체가 실패로 처리한다.

##### 일관성
- 작업 처리 결과가 항상 일관성이 있어야 한다. : 트랜잭션 수행 중 가져온 원래의 데이터가 수정되어도 가져왔던 상태를 유지하여 처리

##### 독립성
- 다른 트랜잭션이 완료될때까지 다른 트랜잭션이 특정 트랜잭션의 결과를 사용할 수 없다.

##### 지속성
- 성공적으로 완료되었을 경우, 결과는 영구적으로 반영된다.

#### JDBC 프로그래밍에서 트랜잭션 처리방법
- ```Connection.setAutoCommit(false)```로 지정
- 트랜잭션이 모두 성공할 경우 ```Connection.commit()``` 호출

#### @EnableTransactionManagement
- Spring Java Config파일에서 트랜잭션을 활성화 할 때 사용하느 ㄴ애노테이션
- PlatformTransactionManager 구현체를 모두 찾아 그 ㅜㅈㅇ 하나를 매핑해 사용


#### 서비스 객체에서 중복으로 호추로디는 코드의 처리
- 서비스는 Repository 객체를 사용하도록 한다.

#### 레이어드 아키텍처

![](https://i.imgur.com/SX19Vr3.png)
- Presentation Layer : 컨트롤러 객체가 동작
- Service Layer : 비지니스 로직을 가진 서비스 객체가 동작
- Repository Layer : 데이터베이스에 접근에서 처리 : 서비스 객체가 여기에 있는 DAO 객체 이용
- 이 세개는 모두 분리하여 다른 객체와 대체되도록 관리 : 설정 분리

#### 설정의 분리
- Spring 설정 파일을 프리젠테이션 레이어 쪽과 나머지를 분리할 수 있따.

### 2)레이어드 아키텍쳐(Layered Architecture) 실습

#### 방명록 만들기 실습
- Spring JDBC를 이용한 Dao 작성
- Controller + Service + Dao
- 트랜잭션 처리
- SpringMVC에서 폼 값 입력받기
- Spring MVC에서 redirect하기
- Controller에서 jsp에게 전달한 값을 JSTL과 EL을 이용해 출력하기

#### 요구사항 1/6
- 방명록 정보는 guestbook 테이블에 저장된다.
- id는 자동으로 입력되낟.
- id, 이름, 내용, 등록일 저장

#### 요구사항 2/6
- http://localhost:8080/guestbook/을 요청하면 자동으로 /guestbook/list로 리다이렉팅한다.
- 방명록이 없으면 건수는 0이 나오고 아래에 방명록을 입력하는 폼이 보여진다.

#### 요구사항 3/6
- 이름과 내용을 입력하고, 등록버튼을 누르면/guestbook/write URL로 입력한 값을 전달하여 저장한다.
- 값이 저장된 이후에는 guestbook/list로 리다이렉트 된다.

#### 요구사항 4/6
- 입력한 한건의 정보가 보여진다.
- 방명록 내용과 폼 사이의 숫자는 방명록 페이지 링크. 방명록 5건단 1페이지로 설정한다.

#### 요구사항 5/6
- 방명록이 6건이 되면 아래 페이지 수가 2건 보여진다. 1페이지를 누르면 guestbook/list?start=0을 요청하고 2페이지를 누ㅡㄹ면 guestbook/list?start=5를 요청하게 된다.
- guestbook/list는 guest/list?start=0과 같다

#### 요구사항 6/6
- 방명록에 글을 쓰거나, 방명록의 글을 삭제할 때는 Log테이블에 클라이언트 ip주소, 등록/삭제 시간, 등록/삭제 정보를 데이터베이스에 저장한다.
- id는 자동으로 입력되도록 한다.


porm.xml
- spring
- webmvc
- jackson
- servlet jstl jsp
- spring jdbc
- mysql
- data source

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
<modelVersion>4.0.0</modelVersion>
<groupId>com.nts.connect</groupId>
<artifactId>guestbook</artifactId>
<packaging>war</packaging>
<version>0.0.1-SNAPSHOT</version>
<name>guestbook Maven Webapp</name>
<url>http://maven.apache.org</url>

<!-- Properties Setting -->
<properties>
	<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
	<spring.version>4.3.5.RELEASE</spring.version>
</properties>

<dependencies>
	<!-- Spring -->
	<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring-context</artifactId>
		<version>${spring.version}</version>
	</dependency>
	<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring-webmvc</artifactId>
		<version>${spring.version}</version>
	</dependency>

	<!-- JACKSON -->
	<dependency>
		<groupId>com.fasterxml.jackson.core</groupId>
		<artifactId>jackson-databind</artifactId>
		<version>2.9.4</version>
	</dependency>

	<!--  Servlet JSP JSTL -->
	<dependency>
		<groupId>javax.servlet</groupId>
		<artifactId>javax.servlet-api</artifactId>
		<version>3.1.0</version>
		<scope>provided</scope>
	</dependency>
	<dependency>
		<groupId>javax.servlet.jsp</groupId>
		<artifactId>javax.servlet.jsp-api</artifactId>
		<version>2.3.1</version>
		<scope>provided</scope>
	</dependency>
	<dependency>
		<groupId>javax.servlet</groupId>
		<artifactId>jstl</artifactId>
		<version>1.2</version>
	</dependency>
	
	<!-- Spring JDBC -->
	<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring-jdbc</artifactId>
		<version>${spring.version}</version>
	</dependency>
	<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring-tx</artifactId>
		<version>${spring.version}</version>
	</dependency>
	
	<!-- mysql -->
	<dependency>
		<groupId>mysql</groupId>
		<artifactId>mysql-connector-java</artifactId>
		<version>5.1.45</version>
	</dependency>

	<!--  JUNIT -->
	<dependency>
		<groupId>junit</groupId>
		<artifactId>junit</artifactId>
		<version>4.12</version>
		<scope>test</scope>
	</dependency>

	<!-- basic data source -->
	<dependency>
		<groupId>org.apache.commons</groupId>
		<artifactId>commons-dbcp2</artifactId>
		<version>2.1.1</version>
	</dependency>
</dependencies>

<build>
	<finalName>guestbook</finalName>
	<plugins>
		<plugin>
			<groupId>org.apache.maven.plugins</groupId>
			<artifactId>maven-compiler-plugin</artifactId>
			<version>3.6.1</version>
			<configuration>
				<source>1.8</source>
				<target>1.8</target>
			</configuration>
		</plugin>
	</plugins>
</build>

</project>

```

```.settting```에서 servlet 3.1로
```
<installed facet="jst.web" version="3.1"/>
```


##### Config 파일 설정

```java
package com.nts.connect.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;
import org.springframework.web.servlet.view.InternalResourceViewResolver;

@Configuration
@EnableWebMvc
@ComponentScan(basePackages = { "com.connect.guestbook.controller" })
public class WebMvcContextConfiguration extends WebMvcConfigurerAdapter{

    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/css/**").addResourceLocations("/css/").setCachePeriod(31556926);
        registry.addResourceHandler("/img/**").addResourceLocations("/img/").setCachePeriod(31556926);
        registry.addResourceHandler("/js/**").addResourceLocations("/js/").setCachePeriod(31556926);
    }
 
    // default servlet handler를 사용하게 합니다.
    @Override
    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
        configurer.enable();
    }
   
    @Override
    public void addViewControllers(final ViewControllerRegistry registry) {
    		System.out.println("addViewControllers가 호출됩니다. ");
        registry.addViewController("/").setViewName("index");
    }
    
    @Bean
    public InternalResourceViewResolver getInternalResourceViewResolver() {
        InternalResourceViewResolver resolver = new InternalResourceViewResolver();
        resolver.setPrefix("/WEB-INF/views/");
        resolver.setSuffix(".jsp");
        return resolver;
    }
}
```

#### DB 설정

Spring jdbc가 이용할 수 있도록 DBConfig 작성
- Configuration 어노테이션으로 config임을 알림
- ```EnableTransactionManagement``` 트랜잭션 관련된 설정을 자동으로 해줌 : 단 사용자간의 트랜잭션 처리를 위한 ```PlatformTransactionManagaer```을 설정하기 위해서는 ```TransactionManagerConfigure```를 구현하고 ```annotationDrivenTransactionManager``` 메소드 오버라이딩


```java
package com.nts.connect.guestbook.config;

import javax.sql.DataSource;

import org.apache.commons.dbcp2.BasicDataSource;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.annotation.EnableTransactionManagement;
import org.springframework.transaction.annotation.TransactionManagementConfigurer;

@Configuration
@EnableTransactionManagement
public class DBConfig implements TransactionManagementConfigurer {
	private String driverClassName = "com.mysql.jdbc.Driver";

	private String url = "jdbc:mysql://localhost:3306/db?useUnicode=true&characterEncoding=utf8";

	private String username = "root";

	private String password = "qwe123";

	@Bean
	public DataSource dataSource() {
		BasicDataSource dataSource = new BasicDataSource();
		dataSource.setDriverClassName(driverClassName);
		dataSource.setUrl(url);
		dataSource.setUsername(username);
		dataSource.setPassword(password);
		return dataSource;
	}

	@Override
	public PlatformTransactionManager annotationDrivenTransactionManager() {
		return transactionManger();
	}

	@Bean
	public PlatformTransactionManager transactionManger() {
		return new DataSourceTransactionManager(dataSource());
	}
}
```

#### AplicationConfig 설정

dao나 service에 구현되어 ㅣㅇ쓴ㄴ 컴포넌트들을 읽어오기 때문에 basePackages에 설정을 넣고 있따.
DBConfig에 사용되ㅗㄱ 있는것으 사용해야하니 DBCOnfig를 @Import 하고 있는걸 볼 수 있따

```java
package com.nts.connect.guestbook.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

@Configuration
@ComponentScan(basePackages = {"com.nts.connect.guestbook.dao", "com.nts.connect.guestbook.service"})
@Import({DBConfig.class})
public class ApplicationConfig {

}
```

### web.xml 수정

- 웹모듈 2.3 수정
- 모든 요청을 DispatcherSerrvlet으로 등록
- 나누어진 설정 파일들을 읽기위해 ```listener```로 ```ContextLoaderListener``` 컨텍스트가 로딩될 때 
- context-param로 읽어들일 클래스를 지정
- filter는 요청이 수행되기전/응답이 나가기전 한번씩 실행 : 인코딩

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app>

	<display-name>Spring JavaConfig Sample</display-name>
	<context-param>
		<param-name>contextClass</param-name>
		<param-value>org.springframework.web.context.support.AnnotationConfigWebApplicationContext
		</param-value>
	</context-param>
	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>com.nts.connect.guestbook.config.ApplicationConfig
		</param-value>
	</context-param>
	<listener>
		<listener-class>org.springframework.web.context.ContextLoaderListener
		</listener-class>
	</listener>

	<servlet>
		<servlet-name>mvc</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet
		</servlet-class>
		<init-param>
			<param-name>contextClass</param-name>
			<param-value>org.springframework.web.context.support.AnnotationConfigWebApplicationContext
			</param-value>
		</init-param>
		<init-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>com.nts.connect.guestbook.config.WebMvcContextConfiguration
			</param-value>
		</init-param>
		<load-on-startup>1</load-on-startup>
	</servlet>
	<servlet-mapping>
		<servlet-name>mvc</servlet-name>
		<url-pattern>/</url-pattern>
	</servlet-mapping>

	<filter>
		<filter-name>encodingFilter</filter-name>
		<filter-class>org.springframework.web.filter.CharacterEncodingFilter
		</filter-class>
		<init-param>
			<param-name>encoding</param-name>
			<param-value>UTF-8</param-value>
		</init-param>
	</filter>
	<filter-mapping>
		<filter-name>encodingFilter</filter-name>
		<url-pattern>/*</url-pattern>
	</filter-mapping>
</web-app>
```

#### DTO DAO 생성


##### 먼저 테이블 생성
```
CREATE TABLE guestbook(
	id bigint(20) unsigned NOT NULL AUTO_INCREMENT,
    name varchar(255) NOT NULL,
    content text,
    regdate datetime,
    PRIMARY KEY(id)
);

CREATE TABLE log(
	id bigint(20) unsigned NOT NULL AUTO_INCREMENT,
    ip varchar(255) NOT NULL,
    method varchar(10) NOT NULL,
    regdate datetime,
    PRIMARY KEY (id)
);
```
##### DTO 생성

guestbook
```java
package com.nts.connect.guestbook.dto;

import java.util.Date;

public class Guestbook {
	private Long id;
	private String name;
	private String content;
	private Date regdate;

	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}

	public Date getRegdate() {
		return regdate;
	}

	public void setRegdate(Date regdate) {
		this.regdate = regdate;
	}

	@Override
	public String toString() {
		return "Guestbook [id=" + id + ", name=" + name + ", content=" + content + ", regdate=" + regdate + "]";
	}

}
```

log
```java
package com.nts.connect.guestbook.dto;

import java.util.Date;

public class Log {
	private Long id;
	private String ip;
	private String method;
	private Date regdate;

	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public String getIp() {
		return ip;
	}

	public void setIp(String ip) {
		this.ip = ip;
	}

	public String getMethod() {
		return method;
	}

	public void setMethod(String method) {
		this.method = method;
	}

	public Date getRegdate() {
		return regdate;
	}

	public void setRegdate(Date regdate) {
		this.regdate = regdate;
	}

	@Override
	public String toString() {
		return "Log [id=" + id + ", ip=" + ip + ", method=" + method + ", regdate=" + regdate + "]";
	}

}
```

##### Dao 작성

LogDao
- ```usingGeneratedKeyColumns``` : id값을 자동으로 설정된다.
- ```insertAction.executeAndReturnKey``` sql을 실행하고 생성된 id를 return한다.

```java
package com.nts.connect.guestbook.dao;

import javax.sql.DataSource;

import org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.jdbc.core.simple.SimpleJdbcInsert;
import org.springframework.stereotype.Repository;

import com.nts.connect.guestbook.dto.Log;

@Repository
public class LogDao {
	private NamedParameterJdbcTemplate jdbc;
	private SimpleJdbcInsert insertAction;

	public LogDao(DataSource dataSource) {
		this.jdbc = new NamedParameterJdbcTemplate(dataSource);
		this.insertAction = new SimpleJdbcInsert(dataSource)
			.withTableName("log")
			.usingGeneratedKeyColumns("id");
	}

	public Long insert(Log log) {
		SqlParameterSource params = new BeanPropertySqlParameterSource(log);
		return insertAction.executeAndReturnKey(params).longValue();
	}
}
```

GuestbookDao
```java
package com.nts.connect.guestbook.dao;

import static com.nts.connect.guestbook.dao.GuestbookDaoSqls.DELETE_BY_ID;
import static com.nts.connect.guestbook.dao.GuestbookDaoSqls.SELECT_COUNT;
import static com.nts.connect.guestbook.dao.GuestbookDaoSqls.SELECT_PAGING;

import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.sql.DataSource;

import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.jdbc.core.simple.SimpleJdbcInsert;
import org.springframework.stereotype.Repository;

import com.nts.connect.guestbook.dto.Guestbook;

@Repository
public class GuestbookDao {
	private NamedParameterJdbcTemplate jdbc;
	private SimpleJdbcInsert insertAction;
	private RowMapper<Guestbook> rowMapper = BeanPropertyRowMapper.newInstance(Guestbook.class);

	public GuestbookDao(DataSource dataSource) {
		this.jdbc = new NamedParameterJdbcTemplate(dataSource);
		this.insertAction = new SimpleJdbcInsert(dataSource)
			.withTableName("guestbook")
			.usingGeneratedKeyColumns("id");
	}

	public List<Guestbook> selectAll(Integer start, Integer limit) {
		Map<String, Integer> params = new HashMap<>();
		params.put("start", start);
		params.put("limit", limit);
		return jdbc.query(SELECT_PAGING, params, rowMapper);
	}

	public Long insert(Guestbook guestbook) {
		SqlParameterSource params = new BeanPropertySqlParameterSource(guestbook);
		return insertAction.executeAndReturnKey(params).longValue();
	}

	public int deleteById(Long id) {
		Map<String, ?> params = Collections.singletonMap("id", id);
		return jdbc.update(DELETE_BY_ID, params);
	}

	public int selectCount() {
		return jdbc.queryForObject(SELECT_COUNT, Collections.emptyMap(), Integer.class);
	}
}
```
GuestbookDaoSqls
- limit를 통해 일정 부분만 가져올 수 있게 해준다.

```java
package com.nts.connect.guestbook.dao;

public class GuestbookDaoSqls {
	public static final String SELECT_PAGING = "SELECT id, name, content, regdate FROM guestbook ORDER BY id DESC limit :start, :limit";
	public static final String DELETE_BY_ID = "DELETE FROM guestbook WHERE id = :id";
	public static final String SELECT_COUNT = "SELECT count(*) FROM guestbook";
}
```


#### Test

```java
package com.nts.connect.guestbook.dao;

import java.util.Date;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

import com.nts.connect.guestbook.config.ApplicationConfig;
import com.nts.connect.guestbook.dto.Guestbook;
import com.nts.connect.guestbook.dto.Log;

public class GuestbookDaoTest {

	public static void main(String[] args) {
		ApplicationContext ac = new AnnotationConfigApplicationContext(ApplicationConfig.class);
		GuestbookDao dao = ac.getBean(GuestbookDao.class);

		Guestbook gb = new Guestbook();
		gb.setName("testname");
		gb.setContent("test 콘텐틍2");
		gb.setRegdate(new Date());
		System.out.println("id : " + dao.insert(gb));

		LogDao logDao = ac.getBean(LogDao.class);
		Log log = new Log();
		log.setIp("127.0.0.1");
		log.setMethod("insert");
		log.setRegdate(new Date());
		logDao.insert(log);

	}

}
```

#### Service Layer 작성

##### 서비스 인터페이스 정의
- 필요한 서비스를 수행할 메소드 작성

GuestbookService
``` java
package com.nts.connect.guestbook.service;

import java.util.List;

import com.nts.connect.guestbook.dto.Guestbook;

public interface GuestbookService {
	public static final Integer LIMIT = 5;

	public List<Guestbook> getGuestbooks(Integer start);

	public int deleteGuestbook(Long id, String ip);

	public Guestbook addGuestbook(Guestbook guestbook, String ip);

	public int getCount();
}

```

##### 서비스 구현
- 서비스에는 @Service 어노테이션 작성
- @autowired를 통해 알아서 생성해서 주입할 수 있도록
- guestbookDao를 통해 필요한 메소드 작성
- ```@Transactional```을 이용하면 내부적으로 readOnly라는 형태로 connection이 지정됨
- ```@Transactional```에 readOnly를 false로 지정하여 트랜잭션 설정

GuestbookServiceImpl
```java
package com.nts.connect.guestbook.service.impl;

import java.util.Date;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.nts.connect.guestbook.dao.GuestbookDao;
import com.nts.connect.guestbook.dao.LogDao;
import com.nts.connect.guestbook.dto.Guestbook;
import com.nts.connect.guestbook.dto.Log;
import com.nts.connect.guestbook.service.GuestbookService;

@Service
public class GuestbookServiceImpl implements GuestbookService {
	@Autowired
	GuestbookDao guestbookDao;

	@Autowired
	LogDao logDao;

	@Override
	@Transactional
	public List<Guestbook> getGuestbooks(Integer start) {
		List<Guestbook> list = guestbookDao.selectAll(start, GuestbookService.LIMIT);
		return list;
	}

	@Override
	@Transactional(readOnly = false)
	public int deleteGuestbook(Long id, String ip) {
		int deleteCount = guestbookDao.deleteById(id);
		Log log = new Log();
		log.setIp(ip);
		log.setMethod("delete");
		log.setRegdate(new Date());
		logDao.insert(log);
		return deleteCount;
	}

	@Override
	@Transactional(readOnly = false)
	public Guestbook addGuestbook(Guestbook guestbook, String ip) {
		guestbook.setRegdate(new Date());
		Long id = guestbookDao.insert(guestbook);
		guestbook.setId(id);

		//		if(1 == 1)
		//			throw new RuntimeException("test exception");

		Log log = new Log();
		log.setIp(ip);
		log.setMethod("insert");
		log.setRegdate(new Date());
		logDao.insert(log);

		return guestbook;
	}

	@Override
	public int getCount() {
		return guestbookDao.selectCount();
	}

}
```

#### controller 작성

GuestbookContorller

```java
package com.nts.connect.guestbook.controller;

import java.util.ArrayList;
import java.util.List;

import javax.servlet.http.HttpServletRequest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.ModelMap;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;

import com.nts.connect.guestbook.dto.Guestbook;
import com.nts.connect.guestbook.service.GuestbookService;

@Controller
public class GuestbookController {
	@Autowired
	GuestbookService guestbookService;

	@GetMapping(path = "/list")
	public String list(@RequestParam(name = "start", required = false, defaultValue = "0") int start,
		ModelMap model) {

		// start로 시작하는 방명록 목록 구하기
		List<Guestbook> list = guestbookService.getGuestbooks(start);

		// 전체 페이지수 구하기
		int count = guestbookService.getCount();
		int pageCount = count / GuestbookService.LIMIT;
		if (count % GuestbookService.LIMIT > 0)
			pageCount++;

		// 페이지 수만큼 start의 값을 리스트로 저장
		// 예를 들면 페이지수가 3이면
		// 0, 5, 10 이렇게 저장된다.
		// list?start=0 , list?start=5, list?start=10 으로 링크가 걸린다.
		List<Integer> pageStartList = new ArrayList<>();
		for (int i = 0; i < pageCount; i++) {
			pageStartList.add(i * GuestbookService.LIMIT);
		}

		model.addAttribute("list", list);
		model.addAttribute("count", count);
		model.addAttribute("pageStartList", pageStartList);

		return "list";
	}

	@PostMapping(path = "/write")
	public String write(@ModelAttribute Guestbook guestbook,
		HttpServletRequest request) {
		String clientIp = request.getRemoteAddr();
		System.out.println("clientIp : " + clientIp);
		guestbookService.addGuestbook(guestbook, clientIp);
		return "redirect:list";
	}
}
```

list.jsp
```html
<%@ page language="java" contentType="text/html; charset=UTF-8"
	pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>
<!DOCTYPE html>
<html lang="ko">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>List</title>
</head>
<body>

	<h1>방명록</h1>
	<br> 방명록 전체 수 : ${count }
	<br>
	<br>

	<c:forEach items="${list}" var="guestbook">

${guestbook.id }<br>
${guestbook.name }<br>
${guestbook.content }<br>
${guestbook.regdate }<br>

	</c:forEach>
	<br>

	<c:forEach items="${pageStartList}" var="pageIndex" varStatus="status">
		<a href="list?start=${pageIndex}">${status.index +1 }</a>&nbsp; &nbsp;
</c:forEach>

	<br>
	<br>
	<form method="post" action="write">
		name : <input type="text" name="name"><br>
		<textarea name="content" cols="60" rows="6"></textarea>
		<br> <input type="submit" value="등록">
	</form>
</body>

</html>
```

11. Controller
------------------------------------------------------------------

### 1)RestController란?

#### @RestController
- Spring4 에서 RestAPI 또는 Web API를 개발하기 위해 등장한 annotation
- 이전 버전의 ```@Controller```와 ```@ResponseBody```를 포함한다.

#### MessageConvertor
- 외부에서 전달바등ㄴ JSON 메서드를 내부에서 사용할 수 있는 객체로 변환하거나 컨트롤러를 리턴한 객체가 클라이언트에게 JSON으로 변환해서 전달할 수 있도록 하는 역할을 한다.

#### Json 응답하기
- jackson라이브러리를 이용한다. : 추가해야 올바르게 동작한다.


### 2)RestController를 이용하여 web api 작성하기

#### 실습
- guestbook에 이어서

##### jackson 추가

















