[??]?
========

  * [마크 다운에 목차 넣는법](#-------------)
  * [Class.forName](#classforname)
  * [StaticBlock](#staticblock)
  * [JavaReflection](#javareflection)
  * [eclipse 플러그인 설치](#eclipse-플러그인-설치)
  * [W3C 유효성 검사](#w3c-유효성-검사)
  * [Mock Object란 무엇인가](#mock-object란-무엇인가)
  * [Annotation](#annotation)
  * [스프링 proxy](#스프링-proxy)

{:toc}



마크 다운에 목차 넣는법
--------------------
https://ecotrust-canada.github.io/markdown-toc/
여기서 생성가능


Class.forName
--------------------
JDBC 드라이버를 로드하는 코드를 보면 Class.forName을 사용하는 것을 볼 수 있다. 이 Class.forName의 의미는 무엇일까?
```java
Class.forName("com.mysql.jdbc.Driver");
Connection conn = DriverManager.getConnection();
```
코드를 살펴보면 리턴값을 받지도 않고 ```DriverManager```의 ```getConnection```메서드를 바로 사용할 수 있다. 또 ```forName```의 인자로 패키지의 경로가 설정된 것을 볼 수 있다. 왜 이렇게 구현한 것일까?
각 JDBC마다 드라이버와 Connection의 구현은 다를 것이다. 각 DBMS마다 다른 API를 사용하여 DB에 연결할 경우
DBMS를 변경할 일이 생기면 복잡한 작업이 될 것이다.
Java에서는 Connection, Driver 인터페이스와 Driver를 등록하고 그 드라이버의 Connection을 리턴해주는 DriverManager 클래스를 제공한다. 각 벤더에서는 Driver와 Conneciton을 구현하고 DriverManager라는 클래스를 통해 사용자가 이들을 사용 하도록한다.
```java
package serviceprovider;
public interface Connection {

}

// package serviceprovider;
public interface Driver {
	Connection getConnection();
}
```
java는 위와 같은 두개의 인터페이스를 제공한다. 각 벤더는 이 인터페이스를 상속하여 드라이버와 커넥션을 구연한다.

```java
//DriverManager 예시
package serviceprovider;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
public class DriverManager {
	private DriverManager() {}
	private static final Map<String,Driver> drivers = new ConcurrentHashMap<String,Driver>();
	public static final String DEFAULT_DRIVER_NAME = "default";
	public static void registerDefaultPrivider(Driver d) {
		System.out.println("Driver 등록");
		registerDriver(DEFAULT_DRIVER_NAME, d);
	}
	public static void registerDriver(String name, Driver d) {
		drivers.put(name,d);
	}
	public static Connection getConnection() {
		return getConnection(DEFAULT_DRIVER_NAME);
	}
	public static Connection getConnection(String name) {
		Driver d = drivers.get(name);
		if(d==null) throw new IllegalArgumentException();
		return d.getConnection();
	}
}
```
```DriverManger```는 드라이버를 등록하고 관리하는 기능을 제공한다. 우리가 처음에 ```DriverManager.getConnection```을 호출하면 여기에 저장이 된다. static으로 변수와 메소드가 선언되어 있기 때문에 객체 생성없이 바로 사용할 수 있다.

```java
	//OracleDriver 클래스의 일부분
	static {
    	defaultDriver = null; Timestamp timestamp = Timestamp.valueOf("2000-01-01 00:00:00.0");
    	try {
	    	if(defaultDriver == null) {
    			defaultDriver = new OracleDriver();
    			DriverManager.registerDriver(defaultDriver);
    		}
    	} catch(RuntimeException runtimeexception) {

    	} catch(SQLException sqlexception) {

	    }
    }
```
Class.forName(String name) 클래스에 의해 클래스가 로드 될 때 static 필드의 내용이 실행된다. <- 그렇다고 합니다.
이를 이용해 class 내부에 static 필드를 통해 자기 자신을 DriverManager 클래스에 등록한다.
Java에서는 어떤 DB든 동일하게 사용할 수 있게 Connection과 DriverManger 등을 인터페이스로 제공하여 각 벤더가 이를 구현하게 만들었다. 이렇게 동일한 인터페이스로 구현하여 Class.forName을 통해 동적으로 객체를 가져와 사용할 수 있다. 결국 어떤 DBMS를 사용하든 DB 사용의 구현은 동일하게 할 수 있다.

StaticBlock
-----------
jdbc 구현 방법을 살펴보다가 클래스 정의 부분에 static 블럭이 있는 것을 봤다. 처음 보는 문법이라서 신기했다. 이런 블록을 초기화 블럭(initialization block)이라고 한다.
```java
class Foo{
    static {
        /* 클래스 초기화 블럭 */
    }

    {   /* 인스턴스 초기화 블럭 */ }
}
```
클래스 초기화 블럭은 클래스 변수의 복잡한 초기화에 사요오딘다. 클래스가 처음 로딩될 때 한번만 수행된다. 인스턴스 초기화 블럭은 인스턴스가 생성될 때 마다 수행된다. 이는 생성자보다 먼저 수행된다.
인스턴스 변수의 초기화는 주로 생성자를 사용하기 때문에 인스턴스 초기화 블럭은 잘 사용되지 않는다.
대신 클래스의 모든 생성자에서 공통적으로 수행되어져야 하는 코드가 있는 경우 생성자에 넣지 않고 인스턴스 초기화 블럭에 넣어 코드 중복을 줄일 수 있다.
DB Driver 구현에서 이 static 필드를 통해 DriverManager에 등록하는 것도 Class.forName을 통해 객체생성을 할 때 최초에 실행되는 것이 static 필드라서 그런 것 같다. static 필드는 동적으로 생성하든 정적으로 생성하든 제일 먼저 실행되기 때문이다.

JavaReflection
--------------

메모리에 올라온 클래스의 정보를 동적으로 가져와서 사용 가능하게 한다.
하지만 성능 이슈 때문에 꼭 필요할 경욱 ㅏ아니면 사용하지 않는다.

eclipse 플러그인 설치
-------------------

webclipse

[help - Eclipse Marketplace] -> webclipse 검색 -> 설치

자바스크립트 코드 자동완성 활성화
[Window - preference] -> JavaScript > Editor > Content Assist -> Enable auto activation 체크 후 저장


W3C 유효성 검사
--------------

[사이트 이동](https://validator.w3.org/unicorn/?ucn_lang=ko)
사이트로 이동해서 파일업로드로 검사하면 됩니다.


Mock Object란 무엇인가
-----------

[참고사이트](https://medium.com/@SlackBeck/mock-object%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-85159754b2ac)


테스트를 위해 사용되는 Object이다

```java
public class CellphoneMmsSender{
	private CellPhoneService cellPhoneService;

	public CellphoneMmsSender(CellPhoneService cellPhoneService){
    	this.cellPhonService = cellPhoneService;
    }

    public void send(String msg){
    	cellPhoneService.sendMMS(msg);
    }
}
```
다음과 같은 코드에서 ```CellphoneMmsSender의 ```send()``` 메서드에 대한 테스트 코드를 어떻게 작성하여야 할까? 반환값 검증도 하나의 방법이지만 여기서는 void를 반환하기 때문에 사용할 수 없다. 다른 방법은 없을까?

```CellphneMmsSender```의 ```send()``` 메서드에서 검증해야 하는 것은 전달받은 ```msg```를  ```CellphoneService.sendMMS```의 파라메터로 호출했는지 여부이다.
이를 위해 ```CellphoneMmsSender```가 참조하고 있는 ```CellphoneService``` 객체를 대역 객체로 대체하고 이를 검증하는 방법이 있다. 여기서 사용하는 가짜 객체를 ```Mock Object```라고 한다.

### Mock Object
Mock Object는 테스트 더블(Test Double) 중 하나이며 오브젝트의 행위를 테스트 한다. 여기서 Double은 대역이라는 의미를 가진다.
위의 예제에서 전달받은 ```msg```를 ```CellphoneService sendMMS()```의 파라메터로 호출했는지 여부가 행위에 해당한다. 이를 검증하며 테스트하는 것이 행위 검증이다.

### Mock Object를 사용한 테스트 코드

```java
public class CellPhoneServiceMock extends CellPhoneService{
	private boolean isSendMMSCalled = false;
    private String sendMsg = "";

    @Override
    public void sendMMS(String msg){
    	//행위 여부를 확인
        isSendMMSCalled = true;
        sendMsg = msg;
    }

    public boolean isSendMMSCalled() {
    	return isSendMMSCallled;
    }

    public String getSendMsg(){
    	return sendMsg;
    }
}
```
```java
public class CellphoneMmsSenderTest{
	@Test
    public void testSend() throws Exeption{
    	final String message = "Test Messgae";

        CellPhoneServiceMock cellPhnoeServiceMock = new CellPhoneServiceMock();

        CellphoneMmsSender cellphoneMmsSender = new CellphoneMmsSender(cellPhoneServiceMock);

        cellphoneMmsSender.send(message);

        Assert.assertTrue(cellPhoneServiceMock.isSendMMSCalled());
        Assert.assertEquals(message, cellPhoneServiceMock.getSendMsg());
    }
}
```
### Mockito를 사용한 테스트 코드
Mock Object를 직접 만들어 테스트할 수도 있지만 일일이 클래스를 만들고 관리하기는 부담스럽다. 이를 지원하는 라이브러리나 프레임워크가 있기 때문에 이를 이용하면 됩니다.

Annotation
----------

자바에서 제공하는 
C++에서 Overrride나 delete 키워드 같이 해당 메서드나 클래스? 등의 유효성 검사 등을 쉽게 할 수 있도록 하는 기능


### Declare Custom Annotation

```java
public @interface MyAnnotation{
	//...
}
```
기본은 이렇고 메타 어노테이션들을 추가로 선언해 주면 됩니다.



스프링 proxy
-----------


